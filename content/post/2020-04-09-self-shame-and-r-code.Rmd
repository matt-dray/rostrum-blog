---
title: Owning the shame of my old R code
author: Matt Dray
date: '2020-04-17'
slug: r-self-shame
categories:
  - code
tags:
  - functions
  - r
  - reproducibility
  - self-help
draft: no
---

<div class="figure">
<img src="/post/2020-04-09-self-shame-and-r-code_files/brehm-1895-hare.jpg" alt="Line drawing of two hares, one of which is standing on its hind legs." width="75%"/>
<p class="caption">Bemusement (all images from [Brehm's Life of Animals, 1895](https://archive.org/details/brehmslifeofanim00breh/page/n8/mode/2up){target='_blank'})</p>
</div>

# tl;dr

In which I reflect on my past-self's bad R practices. Learnings: don't use `file.choose()`, `setwd()`, nor `attach()`; structure your projects sensibly; write functions instead of copy-pasting code.

# A startling discovery

I dug up a time capsule from a decade ago. It contained poorly constructed R code.

Twist: _it was me all along_.

Reading these scripts brought back the sweet nostalgia of running the vanilla R GUI on my [precious white MacBook](https://en.wikipedia.org/wiki/MacBook_(2006%E2%80%932012){target='_blank'}). At the time I was using R as an interactive calculator for [ecological analyses](https://www.rostrum.blog/2019/04/30/markov-chain-phd-2/){target='_blank'}, basically.

What nuggets of pain did I unearth? Past-Matthew seemed to like:

1. `file.choose()` and `setwd()` for non-reproducible [file locations](#files){target='_blank'}
1. The [`attach()`](#attach){target='_blank'} function for basically hiding his data and forgetting it exists
1. Working in [the same R workspace](#env){target='_blank'} at all times regardless of context
1. [Repeating code](#repeat){target='_blank'} over and over and over and over and

This post is a belated learning moment for past-Matthew.

<div class="figure">
<img src="/post/2020-04-09-self-shame-and-r-code_files/brehm-1895-otter.jpg" alt="Line drawing of an otter in agony with its paw trapped in some fishing tackle." width="75%"/>
<p class="caption">Agony</p>

# 1. Falling foul of a file-finding fail {#files}

Can't remember where a file is? Don't want long file paths cluttering your scripts? Nevermind! Past-Matthew was using `file.choose()`, which opens your file explorer so you can navigate to the correct file.

```{r file-choose, eval=FALSE}
df <- read.csv(file.choose())
```

But how can anyone reading your script (including you) know what file you actually read in? It's not recorded in your script. You can't re-run this code without that information.

Solutions: 

* good project-folder structure that puts all the elements of your analysis --- data, scripts, outputs --- in one place so its portable and others can use it without having to change anything
* relative file paths that start from your project folder, so you can use computer-agnostic paths like `data/cool-data.csv` rather `path/specific/to/my/machine/data/cool-data.csv`

Tools:

* [RStudio Projects](https://support.rstudio.com/hc/en-us/articles/200526207-Using-Projects){target='_blank'} encourage good folder structure and have the bonus of relative file paths, which start from the directory containing the .Rproj file. 
* [the {here} package](https://here.r-lib.org/){target='_blank'} by [Kirill Müller](https://twitter.com/krlmlr){target='_blank'} also helps with relative file paths; `here()` finds a file based on the perceived 'home' for the project, or just where a manually-placed hidden `.here` file is placed with `set_here()`

## Justified arson

You may wonder why I haven't mentioned `setwd()` as a solution here. It's because [Jenny Bryan](https://jennybryan.org/){target='_blank'} will [set your computer on fire if you do it](https://www.tidyverse.org/blog/2017/12/workflow-vs-script/){target='_blank'}.

But of course past-Matthew did this.[^melt] He would use `setwd()` to point to where the project was housed locally:

```{r setwd, eval=FALSE}
setwd("/Users/Matthew//local/path/to/project/")
df <- read.csv("data/some_file.csv")
```

What's the problem? The bit in `setwd()` is not reproducible --- it's the file location on one particular machine only!

<div class="figure">
<img src="/post/2020-04-09-self-shame-and-r-code_files/brehm-1895-mouse.jpg" alt="Line drawing of two mice that look like they're laughing." width="75%"/>
<p class="caption">Mirth</p>

# 2. Getting too attached {#attach}

This problem begins with a question: how does R know where to look for a variable?

Here's three ways to calculate Pokémon body mass index by reference to variables in a data set:

```{r df-ref}
# Read Pokémon data from URL
df <- suppressMessages(readr::read_csv(
  "https://raw.githubusercontent.com/mwdray/datasets/master/pokemon_go_captures.csv",
))

# BMI calculation three ways
x <- mean(df$weight_kg / df$height_m ^ 2)  # dollar notation
y <- mean(df[["weight_kg"]] / df[["height_m"]] ^ 2)  # square brackets
z <- with(df, mean(weight_kg / height_m ^ 2))  # with() function

# All produce the same results?
all(x == y, y == z, x == z)
```

So each line specifies the data frame object where R should look for the named variables. If you don't provide this object, R will error:

```{r no-attach-calc, eval=FALSE}
mean(weight_kg / height_m ^ 2)
```

```
## Error in mean(weight_kg / height_m ^ 2) : object 'weight_kg' not found
```

R was searching for the `weight_kg` variable in a few places, starting with the global environment, but couldn't find it. You can see the search path it takes:

```{r search}
search()
```

The data object isn't in there, so that's why it can't find those variables. 

Past-Matthew got around this by using `attach()`, which lets you add objects to the search path.

```{r attach-search}
attach(df)
search()  # now 'df' is in the search path
```

The following expression can now be calculated because R can find the variable names in the attached `df` object.

```{r attach-calc}
mean(weight_kg / height_m ^ 2)
```

So we never need to refer to the data frame name at all. Wow, how can that be bad?

Here's one reason. Consider a data set with column names that match our original:

```{r}
df2 <- df[species == "caterpie", ]
attach(df2)
```

You might be able to guess the problem: R will get variables from `df2` first, since it was the most recently attached.

Bad news: this means the code we wrote earlier will get a different result.

```{r}
mean(weight_kg / height_m ^ 2)
```

This has serious implications for reproducibility and the confidence you can have in your results.[^inferno]

Past Matthew was using this approach because he was taught with [Mick Crawley's R Book](https://www.wiley.com/en-gb/The+R+Book%2C+2nd+Edition-p-9780470973929){target='_blank'}. I disagree with Mick that `attach()` 'makes the code easier to understand for beginners' (page 18), especially because he also says 'avoid using attach wherever possible'.

Pro tip: if you do ever use `attach()` (don't), you'll want to make sure you `detach()` your objects.

```{r}
detach(df)
detach(df2)
```

<div class="figure">
<img src="/post/2020-04-09-self-shame-and-r-code_files/brehm-1895-lemur.jpg" alt="Line drawing of a lemur in a aggressive posture." width="75%"/>
<p class="caption">Scorn</p>
</div>

# 3. Polluting the environment {#env}

Past-Matthew clearly executed different projects and scripts in the same running instance of R.

The potential for confusion and error is high in this scenario. Was the object `results` created from `analysis1.R` or `analysis2.R`? Maybe `results` is now out of date because the code has been updated.

I'm also certain that the content of past-Matthew's workspace was being saved at the end of each session --- the default behaviour --- meaning all that trash would come back next time he fired up R. 

There were also some strange defensive lines like the following, which pre-emptively unloads the {nlme} package because of a namespace conflict with {lme4}:

```{r detach-pkg, eval=FALSE}
detach("package:nlme")  # conflicts with lme4
```

Unnecessary and odd. I assume this was because past-Matthew was never quite sure of the state of his current working environment.

These days I treat everything in my environment with suspicion and restart R regularly and rebuild objects from scratch. This means I can have confidence that my script does what I think it does and also stops interference from older objects that are clogging up my environment.

I also modified the default behaviour of RStudio to prevent my workspace being saved, which means I can start afresh when I open a project. To do this, untick 'Restore .Rdata on startup' and set 'Save workspace to .RData on exit' to 'Never' in Tools > Global Options > General > Basic > Workspace.

[Read more about workflow in the R for Data Science book](https://r4ds.had.co.nz/workflow-projects.html){target='_blank'} by Garrett Grolemund and Hadley Wickham. 

<div class="figure">
<img src="/post/2020-04-09-self-shame-and-r-code_files/brehm-1895-gopher.jpg" alt="Line drawing of two gophers, one side-on and one with its face popping up from a hole." width="75%"/>
<p class="caption">Disgust</p>
</div>

# 4. There's a function for that {#repeat}

Turns out past-Matthew repeated loads of code because functions looked too much like Real Programming and were therefore Quite Hard.

Here's a simple example of code repetition that was pretty common in past-Matthew's scripts:[^semi] 

```{r repetition}
# Subset the data and then get a mean value
sub_koffing <- subset(df, species == "koffing")
mean_koffing <- round(mean(sub_koffing[["weight_kg"]]), 2)

# Do it again for a different species
sub_paras <- subset(df, species == "paras")
mean_paras <- round(mean(sub_paras[["weight_kg"]]), 2)

# Do it again for a different species
sub_geodude <- subset(df, species == "geodude")
mean_geodude <- round(mean(sub_koffing[["weight_kg"]]), 2)

# Print results
mean_koffing; mean_paras; mean_geodude
```

You know this is bad news; copy-pasting leads to mistakes. See how two of those outputs are suspiciously similar? Oops.[^rock]

Functions let you write the meat of the code just once, eliminating the copy-paste error. You can then loop over the variables of interest to get your results.

The effort of learning to write your own functions is worth it to avoid the problems. See [R for Data Science](https://r4ds.had.co.nz/functions.html){target='_blank'} for more on this.

```{r mean-fn}
# Function to calcuate a rounded mean value for a given species
get_sp_mean <- function(sp, var = "weight_kg", dp = 2) {
  
  sub_sp <- subset(df, species == sp)  # subset data
  mean_sp <- round(mean(sub_sp[[var]]), dp)  # get mean
  return(mean_sp)  # function will output the mean value
  
}

# Create a named vector to iterate over
species <- c("paras", "koffing", "weedle")
names(species) <- species

# Iterate over the vector to apply the function
purrr::map(species, get_sp_mean)
```

_Friendship ended with code repetition. Now bespoke functions and {purrr} are my best friends._

<div class="figure">
<img src="/post/2020-04-09-self-shame-and-r-code_files/brehm-1895-loris.jpg" alt="Line drawing of la loris staring into the foreground." width="75%"/>
<p class="caption">Empathy</p>
</div>

# Reflections

I think it's a good exercise to look back and critique your old code. 

There's no shame in writing code that does what you want it to do. I can see why past-Matthew did the things he did. But I'm also glad he stopped doing them.

See you in ten years to look back on the inevitably terrible code I've written in this blog.

---
<details><summary>Session info</summary>
```{r sessioninfo, echo=FALSE}
sessioninfo::session_info()
```
</details>

[^melt]: My darling white plastic MacBook would have melted horribly if set on fire.
[^semi]: Note past-Matthew's use of semi-colons, which I never see anyone use (including present-Matthew).
[^rock]: Especially because Geodude is made of rock and Koffing is basically just made of gas.
[^inferno]: The 'search list shuffle' danger of `attach()` is also referenced in Circle 8.1.35 of [The R Inferno](https://www.burns-stat.com/pages/Tutor/R_inferno.pdf){target='_blank'} by Patrick Burns.