---
title: 'Git going: Git and GitHub'
author: Matt Dray
date: '2019-10-13'
slug: git-going-basics
categories:
  - code
  - tutorial
tags:
  - bash
  - git
  - github
  - terminal
  - shell
  - version control
draft: yes
---

# tl;dr

This post is a basic and non-comprehensive introduction to Git and GitHub, with a focus on Mac users who are starting a project and working alone.

Here's a quick reference for the commonly-used Git commands used in this post:

| Command                     | Short explanation                           |
| :-------------------------- | :------------------------------------------ |
| `git init`                  | Put a folder under version control with Git |
| `git status`                | Show changes                                |
| `git add <file>`            | Confirm the changes to be committed         |
| `git commit -m "<message>"` | Commit the changes with an explanation      |
| `git push`                  | Send your commits to GitHub                 |

This is the second part of a series in using Git and Github. [See the first part about basic use of the commadn line](https://www.rostrum.blog/2019/02/01/git-going-cl/).

# Version control

## Tools

`r icon::fa("git", size = 5)`

[Git](https://en.wikipedia.org/wiki/Git) is a version control system that tracks file changes on your computer, records why they were made and lets you revert to a past state if something goes wrong.

`r icon::fa("github", size = 5)`

[GitHub](https://en.wikipedia.org/wiki/GitHub) is a website where you can store the Git history of your files remotely on the web [^remotes]. It acts as a back-up for your work and its versions; lets you explore your code in your browser in a more visual and interactive way; lets other people see your code in the open and use it themselves; lets you record issues and to-do items; and much, much more.

## This post

Our goal in this post is to put a new project folder under version control with Git and then upload the version history to GitHub. I assume you're a beginner and are, for now, working alone on a project.[^audience]

We'll be using the bash language at the command line to do all of this. This is the place where you write code to tell your computer what to do, which you can access via software like ['Terminal' on a Mac](https://en.wikipedia.org/wiki/Terminal_(macOS)). You may want to [see my earlier post for how to get basic stuff done at the command line](https://www.rostrum.blog/2019/02/01/git-going-cl/) before you continue.

It's okay if you aren't comfortable using the command line. The bottom line is to get your work under some form of version control. You could always use GitHub's drag and drop interface without needing to use the command line at all. There are guides available for [using GitHub without using the command line](https://pixelpioneers.co/blog/2017/using-github-without-the-command-line). 

# Step-by-step

Let's break down the steps required to:

1. set up Git and GitHub (do this once)
1. put a project folder under version control with Git (once per project)
1. save a version of your work and record it on GitHub (rinse and repeat during your project's development)

I've written a section for each of these things. Click a link to jump to that section.

1. [One-time tasks](#one-time):
    a. [Install Git](#install)
    a. [Create a GitHub account](#github-account)
1. [Start a project with Git](#project-setup):
    a. [Create your project folder](#folder)
    a. [Initiate Git](#init)
    a. [Create a .gitignore file](#gitignore)
1. [A Git/GitHub workflow](#git-github-workflow):
    a. [Work on your files](#work)
    a. [Check file status](#status)
    a. [Add changes](#add)
    a. [Commit changes](#commit)
    a. [Add and edit files](#edit)
    a. [Push changes to GitHub](#push)

## 1. One-time tasks {#one-time}

You need to install Git on each computer you'll be working from (feasibly only one computer), but only need to sign up once for GitHub.

### Install Git {#install}

Note that Git is not an 'app'; there's not an icon for it on your computer. It's a bunch of functions installed for use via the command line, with each command preceded with the word `git`.

You can check to see if Git is installed on your machine by asking for its version number from the command line:

```{bash eval=FALSE}
$ git --version
```
```
git version 2.20.1 (Apple Git-117)
```

This response shows that I already have Git installed. If the `git` command isn't recognised then you can [download Git](https://git-scm.com/downloads) and install it.

Once installed, Git needs to know who you are so that your name can be recorded when you make changes. You can introduce yourself by supplying your name and email address at the command line to a special Git configuration file:

```{bash eval=FALSE}
$ git config --global user.name 'Your Name'
$ git config --global user.email 'youremail@address.com'
```

You can print the content of the configuration file to check it's worked. Here's what happens when I do that on my machine:

```{bash eval=FALSE}
$ git config --global --list
```
```
user.name=Matt Dray
user.email=mwdray@gmail.com
```

Excellent, my Git configuration file contains my details. 

### Create a GitHub account {#github-account}

GitHub is free to use but you need an account. Go to the [GitHub website](https://github.com/) and click 'Sign-up for GitHub'. You'll need to provide a username, email address and password.

<img src="/post/2019-08-17-git-going-solo_files/gh-sign-up.png" alt="The GitHub sign-up screen">

When prompted for a subscription level, choose 'free subscription'. You'll be able to do everything you need to do with this type of account; a premium account is more suitable for teams.

You'll be sent an automated email to verify your email address. Click the button in the email to confirm. And you're done!

Check that your GitHub profile page is viewable at `github.com/yourusername` once you've compeleted these steps.

## 2. Project set-up {#project-setup}

The following subsections are about creating a project folder and putting it under version control by activating Git.

### Create your project folder {#folder}

It's [good practice for each project to exist in its own repository (folder)](https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1005510), so all the code, data, tests and documentation are in the same place. Let's create a project folder now.

Using the command line, navigate with `cd` to where we want the folder to be, create it with `mkdir` and then navigate into it:

```{bash eval=FALSE}
$ cd ~/Documents
$ mkdir new-project
$ cd new-project
$ pwd
```
```
/Users/matt/Documents/new-project
```

You could also create a new folder by pointing and clicking; just make sure you navigate to the folder at the command line with `cd`.

### Initiate Git {#init}

So we have our empty project folder, but it's not yet under version control. How can we make Git aware of this folder and start tracking changes? We can `init`iate Git there:

```{bash eval=FALSE}
$ git init
```
```
Initialized empty Git repository in /Users/matt/Documents/new-project/.git
```

What did this do? If you look inside the folder through your file explorer you'll see nothing new. But look what happens when you ask at the command line to list all the files:

```{bash eval=FALSE}
$ ls -a
```
```
.
..
.git
```

So the project folder actually contains a `.git` folder (`.` and `..` are in all folders and represent the current and parent directories). This is where the version information will be stored, among other things. Why can't you see it from the file explorer? Because it starts with a period, which marks it as a hidden file not to be shown unless specifically asked for.

### Create a .gitignore file {#gitignore}

There are files that you may not want to put under version control. This might include sensitive files, large data sets or language-specific artefacts.

You can list such files in a special '.gitignore' file that tells Git not to worry about recording them. Note that this file starts with a period, so it's a hidden file like the `.git` file in the last section.

To create a gitignore file, navigate to your project file and use `touch` to create the file and then `open` it with your computer's default text editor (you can also [edit it from the command line itself](https://www.rostrum.blog/2019/02/01/git-going-cl/#createedit-a-file-with-touchnano)).

```{bash eval=FALSE}
$ touch .gitignore
$ open .gitignore
```

Now to add to the gitignore file. You could start by copying from [a template](https://github.com/github/gitignore), like [the one for R](https://github.com/github/gitignore/blob/master/R.gitignore). As an example, the first file in this template is `.Rhistory` -- a log of all the commands you've typed -- which you probably don't need to track.

You could add things to your gitignore like `secret.csv` to ignore a specific dataset, or `*.csv` (meaning any filename that ends with `.csv`) to ignore all CSV files. Mac users will also want to add `.DS_Store`, which is [a kind of Mac-specific metadata file](https://en.wikipedia.org/wiki/.DS_Store).

Note that we haven't recorded any changes to the folder with Git yet.

## 3. A Git/GitHub workflow {#git-github-workflow}

### Work on your files {#work}

Add a couple of files to your : an R script file called `analysis.R` and a data set `data/data.csv`. file tree ends up looking like this:

```
project/
├── analysis.R
├── data/
│   └── data.csv
├── .git
└── .gitignore
```

Great, let's capture this version with Git.

### Check file status {#status}

Run `git status` to see the files that have been created or modified.

```{bash eval=FALSE}
$ git status
```
```{bash eval=FALSE}
On branch master
Your branch is up to date with 'origin/master'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        created:    data/data.csv
        created:    analysis.R
        created:    .gitignore

no changes added to commit (use "git add" and/or "git commit -a")
```

There's a bunch of output. 

You can see on the indented lines the files that are new or have been changed since last time. All the files will be new the first time you run this process, of course.

Note that any files that are in your .gitignore will not appear here, since they've been ignored.

```{bash eval=FALSE}
On branch master
Your branch is up to date with 'origin/master'.

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

        created:    readme.md
        modified:   analysis.R
        modified:   data/data.csv

no changes added to commit (use "git add" and/or "git commit -a")
```

### Add changes {#add}

Now you need to earmark the files whose changes you want to record. This process is called staging. The stage is a safe place where you can add files to be captured; they're not yet confirmed. This is a preventative measure so you don't accidentally record anything you didn't mean to.

There was a handy reminder in the output of `git status` that tells you what to do next: `use "git add <file>..." to update what will be committed`. In other words, you can type the names of the files you want to record with `git add`:

```{bash eval=FALSE}
git add readme.md analysis.R data/data.csv
```

You could also use `git add .`, where the period means 'all the files'. Be careful if you use this -- you don't want to end up capturing things you didn't mean to.

You won't get any output, so how do we know this worked? Type `git status` again.

```{bash eval=FALSE}
On branch master
Your branch is up to date with 'origin/master'.

Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

        created:    analysis.R
        created:    data/data.csv
        created:    .gitignore
```

These files are now staged and marked as 'changes to be committed'.

If you made a mistake and want to remove files from the stage, you can type `git reset HEAD <filename>`. This line is helpfully printed in the output from `git status`..

### Commit changes {#commit}

When you're happy with the files that have been staged, you can now commit them. This confirms that you want Git to record the changes made to these files.

You commit the staged changes using `git commit`. It's good practice to leave a message explaining what changes were made and why. You can leave a simple message using the `-m` flag of `git commit`:

```{bash eval=FALSE}
git commit -m "Add files to the repository"
[master d870f50] Add files to the repository
 X files changed, 185 insertions(+), 0 deletions(-)
```

The message should be short (typically less than 50 characters) but informative (not just 'changed stuff').[^commit-msg] 

How often should you make commits? It's up to you, but it's probably a good idea to do it when you've completed a section of code that does something useful and that you might want to revert to if there's a problem later.

### Add and edit files {#edit}

Continue to add and edit files, committing them when necessary. Remember to use `git status` to check what changes have been made.

### Push changes to GitHub {#push}

Your Git commits are stored locally on your machine. How do you send them to GitHub so you have a remote copy of your version history? You 'push' them.

```{bash eval=FALSE}
git push
```

# What next?

This post has been for beginners to get to grips with the fundamental Git commands `init`, `status`, `add`, `commit` and `push`.

Git is extremely powerful and does so much more that wasn't covered here. A sensible next step would be to learn more about 'branching' in particular. This involves working on an isolated copy of the repo so you can work safely on new features without fear of ruining the main, or 'master' branch of work. If your development is successful, you can merge it back into the 'master' branch with a 'pull request'.

[^audience]: In fact, the real audience are the participants of the UK government's [Data Science Accelerator](https://www.gov.uk/government/publications/data-science-accelerator-programme/introduction-to-the-data-science-accelerator). Participants are analysts who may have little knowledge of programming.
[^remotes]: Other services are available, like [GitLab](https://about.gitlab.com/) and [BitBucket](https://bitbucket.org/), but we'll focus on GitHub.
[^commit-msg]: You can also commit with both a short message and a longer description. To do this, run `git commit` wihtout the `-m` flag. By default on macOS this will open Vim, a text editor, inside Terminal. Type in your comments and then type <kbd>Esc</kbd> <kbd>:</kbd> <kbd>w</kbd> <kbd>q</kbd> to 'write-quit' (save and exit) and return to the command line.