---
title: Fix leaky {dplyr} pipes
author: Matt Dray
date: '2019-04-01'
slug: fix-leaky-dplyr-pipes
categories:
  - R
tags:
  - dplyr
  - tidylog
  - pipecleaner
  - magrittr
  - tidyverse
draft: yes
---



<p>Matt Dray (<a href="https://www.twitter.com/mattdray">@mattdray</a>)</p>
<div id="tldr" class="section level1">
<h1>TL;DR</h1>
<p>There are lots of ways to debug a pipe.</p>
</div>
<div id="the-pipe" class="section level1">
<h1>The pipe</h1>
<p>The pipe operator, <code>%&gt;%</code>, chains function calls together into ‘pipelines’, which</p>
<blockquote>
<p>semantically changes your code in a way that makes it more intuitive to both read and write</p>
</blockquote>
<p>The {magrittr} package brought this paradigm to R and has been adopted by the wildly popular packages of the tidyverse. Pipes have changed fundamentally how people interact with the R programming language.</p>
</div>
<div id="examples" class="section level1">
<h1>Examples</h1>
<p>Let’s look at three approaches to some simple data manipulation using (1) intermediate objects, (2) nested functions and (3) pipelines. The first two I’m ‘classic approaches’. Let’s say I want the mean sepal width of the setosa and versicolor species of iris and round it to one decimal place.</p>
<p>Since this post is about coding style and not ‘base R versus the tidyverse’, it doesn’t matter what functions I use to actually do the data manipulation. I’m using {dplyr} here to make the comparisons easier and because it loads the pipe operator.</p>
<pre class="r"><code>suppressPackageStartupMessages(library(dplyr))</code></pre>
<div id="pipes" class="section level2">
<h2>Pipes</h2>
<p>With the pipe paradigm, the thing you make on the left-hand side of the pipe is passed to the right until the end. You can chain functions together cleanly in the order that the operations occur.</p>
<pre class="r"><code>iris_pipe &lt;- iris %&gt;%
  filter(Species %in% c(&quot;setosa&quot;, &quot;versicolor&quot;)) %&gt;% 
  group_by(Species) %&gt;% 
  summarise(`Mean width` = mean(Sepal.Width)) %&gt;% 
  mutate(`Mean width` = round(`Mean width`, 1))

iris_pipe</code></pre>
<pre><code>## # A tibble: 2 x 2
##   Species    `Mean width`
##   &lt;fct&gt;             &lt;dbl&gt;
## 1 setosa              3.4
## 2 versicolor          2.8</code></pre>
<p>This method is more readable than the classic approaches. It doesn’t have to repeat the data object in each call like the intermediate-objects approach and it is far more readable than the onion method.</p>
<p>So what’s the problem? It’s been suggested that the approach obscures the manipulations and doesn’t allow you to interrogate what’s happening to your dataset after each function call.</p>
<blockquote class="twitter-tweet" data-lang="en">
<p lang="en" dir="ltr">
Method chaining when doing data analysis can be both a good and bad idea depending on when it is done and who is doing it. When first exploring the data, it makes verifying results difficult. Beginners should almost never do it either.
</p>
— Ted Petrou (<span class="citation">@TedPetrou</span>) <a href="https://twitter.com/TedPetrou/status/1109519764613787648?ref_src=twsrc%5Etfw">March 23, 2019</a>
</blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<p>I would argue that you should be checking your data object as you program interactively and this shouldn’t be a problem; you don’t just create one bug pipeline all in one go without checking as you add each function.</p>
<p>But let’s say I haven’t been checking my code as I build my pipeline. How can I assure myself that each step has impacted the data as I wanted it to?</p>
</div>
</div>
<div id="checking-for-leaks" class="section level1">
<h1>Checking for leaks</h1>
<div id="be-sensible" class="section level2">
<h2>Be sensible</h2>
<p>Of course, the simplest answer is to break your pipelines into smaller sensibly-sized objects and inspect them as you go.</p>
<p>How many objects? That depends on what you’re doing. Maybe two for our example (1) filtering for species and (2) calculating the mean. In fact, we may want to perform other operations on the filtered data, so it makes sense to keep it in memory.</p>
<pre class="r"><code>filter_step &lt;- filter(iris, Species %in% c(&quot;setosa&quot;, &quot;versicolor&quot;))
  
summarise_step &lt;- filter_step %&gt;% 
  group_by(Species) %&gt;% 
  summarise(`Mean width` = mean(Sepal.Width)) %&gt;% 
  mutate(`Mean width` = round(`Mean width`, 1))</code></pre>
</div>
<div id="tidylog" class="section level2">
<h2>{tidylog}</h2>
<p><a href="https://github.com/elbersb/tidylog">The {tidylog} package</a> prints to the console the changes that have happened to your data after each {dplyr} step. This means you can check that each step occurred as expected without having to run one line at a time.</p>
<pre class="r"><code>library(dplyr)
library(tidylog)  # must be loaded after dplyr</code></pre>
<pre><code>## 
## Attaching package: &#39;tidylog&#39;</code></pre>
<pre><code>## The following objects are masked from &#39;package:dplyr&#39;:
## 
##     add_count, add_tally, anti_join, count, distinct,
##     distinct_all, distinct_at, distinct_if, filter, filter_all,
##     filter_at, filter_if, full_join, group_by, group_by_all,
##     group_by_at, group_by_if, inner_join, left_join, mutate,
##     mutate_all, mutate_at, mutate_if, right_join, select,
##     select_all, select_at, select_if, semi_join, summarise,
##     summarise_all, summarise_at, summarise_if, summarize,
##     summarize_all, summarize_at, summarize_if, tally, top_n,
##     transmute, transmute_all, transmute_at, transmute_if</code></pre>
<pre><code>## The following object is masked from &#39;package:stats&#39;:
## 
##     filter</code></pre>
<p>You can see from the output that {tidylog} is masking every {dplyr} functions. It’s hijacking them so you can get output like the following:</p>
<pre class="r"><code>iris_pipe &lt;- iris %&gt;%
  filter(Species %in% c(&quot;setosa&quot;, &quot;versicolor&quot;)) %&gt;% 
  group_by(Species) %&gt;% 
  summarise(`Mean width` = mean(Sepal.Width)) %&gt;% 
  mutate(`Mean width` = round(`Mean width`, 1))</code></pre>
<pre><code>## filter: removed 50 out of 150 rows (33%)</code></pre>
<pre><code>## group_by: one grouping variable (Species)</code></pre>
<pre><code>## summarise: now 2 rows and 2 columns, ungrouped</code></pre>
<pre><code>## mutate: changed 2 values (100%) of &#39;Mean width&#39; (0 new NA)</code></pre>
<p>Note that we haven’t yet called the object, but you can see that we’re getting output in the form of the messages tidylog is posting in the console.</p>
<p>I’ll unload {tidylog} before continuing so it doesn’t interfere with the other examples.</p>
<pre class="r"><code>unloadNamespace(&quot;tidylog&quot;)</code></pre>
</div>
<div id="viewpipesteps" class="section level2">
<h2>{ViewPipeSteps}</h2>
<p><a href="https://github.com/daranzolin/ViewPipeSteps">The {ViewPipeSteps} package</a> allows you to inspect the data produced with each {dplyr} function call in your pipeline. It’s equivalent to running <code>View()</code> for each of the steps in your pipeline without actually having to clutter up your script.</p>
<p>This one’s an RStudio add-in. You can choose to <code>print()</code> to console or <code>View()</code> each step in its own tab.</p>
<pre class="r"><code>iris_vps &lt;- iris %&gt;%
  filter(Species %in% c(&quot;setosa&quot;, &quot;versicolor&quot;)) %&gt;% 
  group_by(Species) %&gt;% 
  summarise(`Mean width` = mean(Sepal.Width)) %&gt;% 
  mutate(`Mean width` = round(`Mean width`, 1))</code></pre>
</div>
<div id="magrittr" class="section level2">
<h2>{magrittr}</h2>
<p><a href="https://magrittr.tidyverse.org/reference/debug_pipe.html" class="uri">https://magrittr.tidyverse.org/reference/debug_pipe.html</a></p>
<pre class="r"><code>library(magrittr)

iris_pipe &lt;- iris %&gt;%
  filter(Species %in% c(&quot;setosa&quot;, &quot;versicolor&quot;)) %&gt;% 
  group_by(Species) %&gt;% 
  summarise(`Mean width` = mean(Sepal.Width)) %&gt;% debug_pipe() %&gt;% 
  mutate(`Mean width` = round(`Mean width`, 1))</code></pre>
<pre><code>## Called from: debug_pipe(.)
## debug: x</code></pre>
</div>
<div id="pipecleaner" class="section level2">
<h2>{pipecleaner}</h2>
<p>devtools::install_github(“alistaire47/pipecleaner”)
<a href="https://github.com/alistaire47/pipecleaner" class="uri">https://github.com/alistaire47/pipecleaner</a></p>
</div>
<div id="pipes-1" class="section level2">
<h2>{pipes}</h2>
<p>devtools::install_github(“moodymudskipper/pipes”)</p>
<pre class="r"><code>library(pipes)</code></pre>
<pre><code>## 
## Attaching package: &#39;pipes&#39;</code></pre>
<pre><code>## The following objects are masked from &#39;package:magrittr&#39;:
## 
##     %&lt;&gt;%, %&gt;%, %$%, %T&gt;%, freduce</code></pre>
<pre><code>## The following object is masked from &#39;package:dplyr&#39;:
## 
##     %&gt;%</code></pre>
<pre class="r"><code>iris_pipe &lt;- iris %&gt;%
  filter(Species %in% c(&quot;setosa&quot;, &quot;versicolor&quot;)) %&gt;% 
  group_by(Species) %&gt;% 
  summarise(`Mean width` = mean(Sepal.Width)) %V&gt;%
  mutate(`Mean width` = round(`Mean width`, 1))

unloadNamespace(&quot;pipes&quot;)</code></pre>
</div>
<div id="tamper" class="section level2">
<h2>{tamper}</h2>
<p>devtools::install_github(“gaborcsardi/tamper”)
<a href="https://github.com/gaborcsardi/tamper" class="uri">https://github.com/gaborcsardi/tamper</a></p>
</div>
<div id="bizarro-pipe" class="section level2">
<h2>Bizarro pipe</h2>
<p>We can hack our own ‘operator’ that acts like a pipe and can be run so that we can check what’s happening at each step.</p>
<p>It’s <a href="http://www.win-vector.com/blog/2017/01/using-the-bizarro-pipe-to-debug-magrittr-pipelines-in-r/">a ‘Bizarro pipe’</a>: <code>-&gt;.;</code>. What it’s saying is ‘right-assign to a dot and then perform the next operation’.</p>
<p>Things you might be wondering:</p>
<ul>
<li>yes, you can use a <code>-&gt;</code> for assignment</li>
<li>yes, you can assign to a <code>.</code>, but you’ll need to explicitly supply it as the data argumnt to the next function call in your ‘Bizarro pipeline’</li>
<li>yes, you can use semi-colons in R for run-on code execution (try <code>head(iris); tail(iris)</code>)</li>
</ul>
<p>So what? Well, you can exeute each line in turn and check the output. But wait: an object called <code>.</code> is not presented in the global environment. No, unless you check ‘Show .Last.value in environment listing’ in RStudio’s settings. Now when you run the line you’ll see the ‘.Last.value’ that’s been output.</p>
<pre class="r"><code>iris_bizarre &lt;- iris -&gt;.;
  filter(., Species %in% c(&quot;setosa&quot;, &quot;versicolor&quot;)) -&gt;.;
  group_by(., Species) -&gt;.;
  summarise(., `Mean width` = mean(Sepal.Width)) -&gt;.;
  mutate(., `Mean width` = round(`Mean width`, 1))</code></pre>
<pre><code>## # A tibble: 2 x 2
##   Species    `Mean width`
##   &lt;fct&gt;             &lt;dbl&gt;
## 1 setosa              3.4
## 2 versicolor          2.8</code></pre>
</div>
</div>
<div id="base-r" class="section level1">
<h1>Base R</h1>
<p>What was it like in the good old days?</p>
<div id="intermediate-objects" class="section level2">
<h2>Intermediate objects</h2>
<p>In the first approach we make a series of intermediate objects, each created using a single function.</p>
<pre class="r"><code>iris_filter &lt;- filter(iris, Species %in% c(&quot;setosa&quot;, &quot;versicolor&quot;))
iris_group &lt;- group_by(iris_filter, Species)
iris_mean &lt;- summarise(iris_group, `Mean width` = mean(Sepal.Width))
iris_mutate &lt;- mutate(iris_mean, `Mean width` = round(`Mean width`, 1))

iris_mutate</code></pre>
<pre><code>## # A tibble: 2 x 2
##   Species    `Mean width`
##   &lt;fct&gt;             &lt;dbl&gt;
## 1 setosa              3.4
## 2 versicolor          2.8</code></pre>
<p>This seems sensible. You can create and interrogate these objects to make sure they do what you want. But this also makes your environment untidy because you have a bunch of halfway-house objects that may serve no standalone purpose beyond being passed into the next object. It could be tricky to keep track of these objects as they swell in your environment, particularly if they get labelled <code>temp1</code>, <code>temp2</code>, <code>temp3</code>, etc.<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a></p>
</div>
<div id="onions" class="section level2">
<h2>Onions</h2>
<p>We can do away with all the intermediate steps by nesting the functions inside each other so that functions are applied to the layer below them.</p>
<pre class="r"><code>iris_onion &lt;-
  mutate(
    summarise(
      group_by(
        filter(iris, Species %in% c(&quot;setosa&quot;, &quot;versicolor&quot;)),
        Species
      ),
      `Mean width` = mean(Sepal.Width)
    ),
    `Mean width` = round(`Mean width`, 1)
  )

iris_onion</code></pre>
<pre><code>## # A tibble: 2 x 2
##   Species    `Mean width`
##   &lt;fct&gt;             &lt;dbl&gt;
## 1 setosa              3.4
## 2 versicolor          2.8</code></pre>
<p>I’ve called this the onion method. Why? Because it’s made up of multiple layers. And it makes you cry a bit to look at it.</p>
</div>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>I’m looking at you, past-Matt!<a href="#fnref1" class="footnote-back">↩</a></p></li>
</ol>
</div>
