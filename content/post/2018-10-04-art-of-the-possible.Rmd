---
title: Art of the Possible
author: Matt Dray
date: '2018-10-04'
slug: art-of-the-possible
categories: []
tags: []
draft: true
---

Matt Dray

# Colour search

Searching images by colour is all the rage:

* [Google Arts & Culture](https://artsexperiments.withgoogle.com/artpalette/colors/a46053-433932-c2ad8f-b5996a-746251)
* [Designspiration](https://www.designspiration.net/search/saves/?q=%2389ebd7%20%23afff11%20%23e5ff91%20%23ff9775%20%23f38d00)
* [TinEye Multicolr](https://labs.tineye.com/multicolr/)
* [Google Advanced Image Search](https://www.google.co.uk/advanced_image_search)
* [Dulux colour match](https://www.dulux.co.uk/en/articles/dulux-visualizer-app)

To do this you need to know how much of each colour is in the image.

So let's look at a kind-of-crappy half-baked method in R for achieving this.

# A very simple implementation

The steps go like this:

1. Read in an image
2. Convert RGB (Red-Green-Blue) values to simple-named colours
3. Get percentage of image filled by each colour
4. ???
5. Profit

# Read image

There's a number of ways to read images into R. We'll use the `readImage()` function from the `OpenImageR` package.

Remember to use `install.packages()` if you haven't installed any of the packages in this post. I'm also assuming that you have a test image, named `test_image.jpg`, in a folder called `img` in your working directory.

```{r eval=FALSE}
library(OpenImageR)  # load package
image_in <- readImage("img/test_image.jpg")  # read image
```

The image has been read into R as an *array*, an object type that can hold data in multiple dimensions.

Our image has three dimensions: a two-dimensional matrix representing the 'pixels' of the image plus [a third dimension for each 'colour channel' of red, green and blue (RGB)](https://en.wikipedia.org/wiki/Channel_(digital_image)).

You can see this when you check the `str`ucture of the image:

```{r eval=FALSE}
str(image_in)  # check structure
```

So it's `[matrix rows, matrix columns, colour channels]`. There'll be three colour channels, of course: RGB. The number of rows and columns will depend on how big the image is.

So we could get the values of each colour channel for the top-left nine pixels of the image (a three-by-thre matrix).

```{r eval=FALSE}
# first three elements of first two dimensions
# and all the elements of the third dimension
image_in[1:3, 1:3, ]
```

For example, a point will be yellow if it has maximum values for red and blue channels and the minimum value in the green channel. [There are online tools for exploring RGB permutations](http://web.stanford.edu/class/cs101/image-rgb-explorer.html).

To prove we can rebuild the image from the array, we can use the `imageShow()` function from `OpenImageR`.

```{r eval=FALSE}
imageShow(image_in)
```

# Tidy the data

We begin by reorganising the array into a dataframe using `melt()` from the `reshape2` package.[^reshape2] This gives us four columns: one for each pixel's x and y value, one for the RGB channel (1 = red, 2 = green, 3 = blue) and one that gives the actual colour value for that channel.

```{r eval=FALSE}
library(dplyr)
library(reshape2)

image_melt <- image_in %>%
  melt() %>% 
  rename(
    y_val = Var1,
    x_val = Var2,
    rgb_channel = Var3,
    rgb_value = value
  )

head(image_melt)
```

What we actually want is a dataframe with columns for each of the RGB channels. Since we're working with a dataframe, we can use the `spread()` funciton in the `tidyr` package to set our 'key' as the RGB channel (i.e. the single column from which the levels will become new columns) and the 'value' as the RGB values. We multiply these values by 255 to get the classic 0 to 255 range. 

```{r eval=FALSE}
library(tidyr)
library(tibble)

image_spread <- image_melt %>% 
  spread(
    key = rgb_channel,
    value = rgb_value
  ) %>% 
  transmute(
    red = round(`1` * 255),
    green = round(`2` * 255),
    blue = round(`3` * 255)
  ) %>%
  rownames_to_column() %>% 
  as_tibble()

head(image_spread)
```

So we have a four coloumn dataframe: a column for each RGB channel and a column for arbitrary rownames. We don't need to worry about the x and y values right now because we don't want to rebuild the image, we just want to count the colours. 

# Assign simple colours

You could do k-means clustering to bucket the full colour set into *k* groups, each with a representative RGB value. This is a good approach for simplifying images; you could go from 256 colours to 8, for example. [You can find methods for this online]().

But actually we want to describe the image with *simple* colours, not the average of a cluster. So we could first convert the RGB values in our array to a set of basic colours with recognisable names like 'yellow' and 'black'. Then we just tally them.

We can do this for each of our pixels by looking for the nearest-neighbour point in RGB space that describes a predefined 'simple' colour. 

It's kind of tricky to decide what these colours should be. One approach might be to use 'extreme' colours. For example, 'blue' could be categorised as lowest values for R and G, but highest value of B `[0, 0, 255]`

```{r eval=FALSE}
simple_colors <- tibble::tribble(
  ~color, ~red, ~green, ~blue,
  "aqua",   0,   255, 255,
  "black",   0,   0,   0,
  "blue",    0,   0,   255,
  "fuchsia", 255, 0,   255,
  "gray",    128, 128, 128,
  "green",   0,   128, 0,
  "lime",    0,   255, 0,
  "red",     128, 0,   0,
  "navy",    0,   0,   128,
  "olive",   128, 128, 0,
  "purple",  128, 0,   128,
  "red",     255, 0,   0,
  "silver",  192, 192, 192,
  "teal",    0,   128, 128,
  "white",   255, 255, 255,
  "yellow",  255, 255, 0
)
```

We want to find the named point (e.g. yellow is at the point [255, 255, 0]) closest to each pixel and assign it that name.

We can do this by calculating the sum of the squared difference between the pixel value and named-point values for each colour channel. The pixel will be assigned where the calculated value is smallest.

```{r eval=FALSE}
rgb_image$color_name <- sapply(
  seq_along(rgb_image$hex),
  function(i) 
    simple_colors$color[
      which.min(
        (simple_colors$red - rgb_image$red[i])^2 +
          (simple_colors$green - rgb_image$green[i])^2 +
          (simple_colors$blue - rgb_image$blue[i])^2
      )
      ]
)
```

# Sum the colours

And now we just work out the percentage of pixels belonging to each colour.

```{r eval=FALSE}
image_colours <- image_spread %>% 
  tabyl(color_name) %>% 
  arrange(desc(percent))

print(image_colours)
```

# Session info

```{r}
xfun::session_info(c("OpenImageR", "dplyr", "reshape2", "tidyr", "tibble", "xfun"), 
  dependencies = FALSE)
```


[^reshape2]: Yeah, `reshape2` has been superseded by `tidyr`, but the latter was built to deal with dataframes specifically. We're working with an array as input. 