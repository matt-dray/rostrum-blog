---
title: "Automated pathfinding in {r.oguelike}"
author: 'Matt Dray'
date: '2022-06-10'
slug: basic-search
categories:
  - code
  - package
tags:
  - breadth-first
  - pathfinding
  - r
  - r.oguelike
  - search
draft: no
---

```{r, include = FALSE}
knitr::opts_chunk$set(comment = "")
```

<div class="figure">
<img src="/post/2022-06-10-basic-search_files/pathfind-dungeon.gif" alt="Animation of an R console, showing a rectangular grid of tiles that represents a dungeon room. Floor tiles are periods. Surrounding walls are hashmarks. There's an enemy character represented by a letter 'E' in the lower left, and a player character represented by an 'at' symbol toward the right. There's some obstacle walls separating them. The enemy character moves tile by tile around the obstacle until it reaches the player." width="100%"/>
<p class="caption">Automated pathfinding in R. Look out behind you!</p>
</div>

# tl;dr

I've experimented with simple breadth-first search for the work-in-progress [{r.oguelike}](https://github.com/matt-dray/r.oguelike) package, which lets enemies chase down the player character.

# Hunting the hunter

I've [written before about the inception of {r.oguelike}](https://www.rostrum.blog/2022/04/25/r.oguelike-dev/), a simple work-in-progress [roguelike game](https://en.wikipedia.org/wiki/Roguelike) in an R package, as well as a simple method for creating [procedural tile-based cave-like dungeons](https://www.rostrum.blog/2022/05/01/dungeon/).

<div class="figure">
<img src="/post/2022-04-13-r.oguelike-dev_files/r.oguelike-hex.png" alt="Hex sticker design for the 'r.oguelike' R package. Black background with bright green font, reminiscent of old computer terminal output. In the centre, a three-by-ten arrangement of hashmarks and periods, along with a single at symbol and dollar sign, which looks like a classic ACII tile-based roguelike game. The text 'r.oguelike' is underneath." width="25%"/>
</div>

The enemies have been stationary and it's been bothering me. I could either let the enemy wander randomly (easy to implement, but boring and unrealistic) or---much better--- introduce some kind of pathfinding so the enemy can 'hunt down' the player (various levels of difficulty for implementation, but more realistic).

# Layers deep

So in this we'll look at pathfinding in R with what I'm calling 'layered' matrices. One matrix is the tile map, which holds the tiles the user sees (i.e. `#` for walls, `.` for floor, `@` for the player character, `E` for enemy). The second matrix isn't seen by the user, but holds travel-distance scores used by the enemy character to find a path to the target.

I'll use `m` throughout as the name of the matrix object holding the tile map and `d` as the name of the matrix object holding the distance map.

# Don't keep it simple, stupid

Consider this very basic dungeon room that hosts an enemy character `E` that is seeking the player character `@`. It's just an R matrix object.

<details><summary>Click for R code</summary>

Manually create a basic, rectangular dungeon room:

```{r}
# Create room
n_rows <- 9
n_cols <- 10
m <- matrix(rep(".", n_rows * n_cols), n_rows, n_cols)
m[1, ] <- "#"  # walls
m[, 1] <- "#"
m[nrow(m), ] <- "#"
m[, ncol(m)] <- "#"

# Add player and enemy
m[7, 3] <- "@"  # player
m[3, 3] <- "E"  # enemy
```

For convenience, a function that pretty-prints the matrix to the console:

```{r}
# Function to print the map nicely
print_tiles <- function(x) {
  for (i in seq(nrow(x))) {
    cat(x[i, ], "\n")
  }
}
```
```{r eval=FALSE}
print_tiles(m)
```
</details>

```{r echo=FALSE}
print_tiles(m)
```

The simplest approach would be to label every traversable tile with [a Manhattan-distance score](https://en.wikipedia.org/wiki/Taxicab_geometry) (i.e. like a taxicab would move on the gridded streets of New York) away from the player's position, then have the enemy check its neighbouring tiles and select the next largest score until it reaches the player.

Here I've created a distance map by assigning the player position a score of 100, then I've decreased the score by 1 with each additional tile away from the player. Walls score zero, so they're effectively ignored.

<details><summary>Click for R code</summary>
```{r}
get_distance <- function(m, peak_score) {

  # Initiate distance matrix filled with zero
  n_rows <- nrow(m)
  n_cols <- ncol(m)
  d <- matrix(rep(0, n_cols * n_rows), n_rows, n_cols)

  # Player location gets peak_score
  player_loc <- which(m == "@", arr.ind = TRUE)
  m[player_loc[1], player_loc[2]] <- peak_score

  # Surrounding tiles get successively smaller distance scores
  for (col_ind in seq(n_cols)) {
    for (row_ind in seq(n_rows)) {
      distance <- abs(player_loc[1] - row_ind) + abs(player_loc[2] - col_ind)
      value <- peak_score - distance
      if (value < 0) value <- 0
      d[row_ind, col_ind] <- value
    }
  }

  # Walls aren't traversable, assign low value
  walls <- which(m == "#")
  d[walls] <- 0

  d

}
```
```{r eval=FALSE}
get_distance(m, 100)
```
</details>

```{r echo=FALSE}
get_distance(m, 100)
```

So the enemy would move from its start position at [3,3] to the target position at [7,3], moving along a score gradient of 96 to 100.

There's an issue with this though: obstacles. What do you think will happen if we put a dividing wall between the characters?

<details><summary>Click for R code</summary>
```{r}
m[5, 2:8] <- "#"
```
```{r eval=FALSE}
print_tiles(m)
```
</details>
```{r echo=FALSE}
print_tiles(m)
```

<details><summary>Click for R code</summary>
```{r eval=FALSE}
d <- get_distance(m, 100)

d
```
</details>
```{r echo=FALSE}
d <- get_distance(m, 100)

d
```

Yeah, the enemy will make a beeline directly for the player and get stuck if anything is in the way.

The enemy starts on 96 at [3,3] and will move south to 97 on [4,3]. Now what? The wall has been scored as zero, so the enemy looks around for the largest value of its remaining neighbours and randomly selects west, north or east, which all have a distance score of 96. 

The enemy will then be stuck in an infinite loop between the adjacent scores of 96 and 97. This isn't very intelligent.

# Here comes the flood-fill

Perhaps a better approach is to 'flood fill' distance scores, starting from the player character's tile, so that scores can 'wrap around' obstacles. Enemies will therefore be capable of navigating around a blockage.

There are several ways to achieve this. Perhaps the most basic is ['breadth-first'](https://en.wikipedia.org/wiki/Breadth-first_search), which visits tiles in a 'frontier' expanding from the start point and assigns distance scores to frontier tiles that are in a 'queue'. This is slightly expensive because every traversable tile has to be assessed, but it means that multiple enemies can all use the same distance map to navigate.[^complicated]

We don't need to get too complicated for {r.oguelike}; it just has to work. I'll illustrate the breadth-first approach with a pretty basic and verbose implementation.[^implementation]

## Deep breadth-first

I'm going to use three functions:

1. `initiate_distance_map()`, which creates a distance-map matrix of equal size to the tile map and fills all traversable spaces with `0` and all non-traversable spaces with `Inf`inity
1. `populate_distance_map`, which 'flood-fills' the traversable space by expanding a 'frontier' from the start point, assigning a distance score to each neighbour that's +1 of the score of the parent tile and adding those neighbours to the frontier queue so they can be inspected next
1. `move_enemy()` to move the enemy character from the largest distance score to the lowest, where the player character is

### Distance map

First, to initiate the distance map:

```{r}
initiate_distance_map <- function(m) {

  d <- m  # copy the tile map
  d[which(d != "#")] <- 0  # set non-wall tiles to 0
  d[which(d == "#")] <- Inf  # set wall tiles to infinity
  matrix(as.numeric(d), nrow(d), ncol(d))  # recast as numeric

}
```

Now we can adjust those distance scores. The algorithm is basically:

1. Create a 'frontier' vector of tile indices  (i.e. the edges of the flood-fill as it moves outward) and add the starting tile (i.e. the tile index that holds the player character)
2. Create a vector to hold tile indices that we've already visited
3. Begin a loop where:
    - the first tile in the frontier queue becomes the 'current' tile
    - the current tile is removed to the frontier
    - the current tile is added to the visited list
    - the tile indices of the current tile's neighbours (north, south, east and west) are identified
    - if not yet visited, the neighbours are assigned distance scores that are +1 of the current tile
4. Continue the loop until you run out of tiles in the frontier queue

### Calculate distances

I've written a sub-function to handle the neighbour-finding:

```{r}
get_neighbours <- function(m, current) {

  n_rows <- nrow(m)

  c(
    if (m[current - n_rows] != "#") current - n_rows,
    if (m[current - 1] != "#") current - 1,
    if (m[current + 1] != "#") current + 1,
    if (m[current + n_rows] != "#") current + n_rows
  )

}
```

Which plugs into the main function for assigning scores to the distance matrix:

```{r}
populate_distance_map <- function(m, d) {

  start <- which(m == "@")  # start tile, i.e. player tile
  
  # Initiate vectors
  frontier <- start  # to be assessed
  visited <- c()  # have been assessed

  while (length(frontier) > 0) {

    current  <- frontier[1]  # set first tile of frontier as current
    frontier <- frontier[!frontier == current]  # remove current tile from frontier
    visited  <- append(visited, current)  # mark current as visited

    neighbours <- get_neighbours(m, current)  # get vector of neighbour indices
    neighbours <- neighbours[!neighbours %in% visited]

    for (neighbour in neighbours) {
      if (!neighbour %in% visited) {  # only assign distance to unvisited neighbours
        d[neighbour] <- d[current] + 1  # assign distance, one more than parent
      }
    }

    frontier <- append(frontier, neighbours)  # add neighbour to the frontier

  }

  d

}
```

### Move to target

Finally, a function that allows the enemy to check its neighbours for the lowest distance score and move there:

```{r}
move_enemy <- function(m, d) {

  # Find tiles of interest
  en_loc <- which(m == "E")
  player_loc <- which(m == "@")
  n_rows <- nrow(m)

  # Get neighbour tile indices
  ind <- c(
    n = en_loc - 1,
    s = en_loc + 1,
    e = en_loc + n_rows,
    w = en_loc - n_rows
  )

  # Get tile content for neighbours
  tiles <- c(
    n = m[ind["n"]],
    s = m[ind["s"]],
    e = m[ind["e"]],
    w = m[ind["w"]]
  )

  # Get the distance score for a tile if traversable/target
  dist <- c(
    n = if (tiles["n"] %in% c(".", "@")) d[ind["n"]],
    s = if (tiles["s"] %in% c(".", "@")) d[ind["s"]],
    e = if (tiles["e"] %in% c(".", "@")) d[ind["e"]],
    w = if (tiles["w"] %in% c(".", "@")) d[ind["w"]]
  )

  # Sample a direction if there's ties, move there
  direction <- sample(names(dist[dist == min(dist)]), 1)
  en_loc_new <- ind[names(ind) == direction]
  m[en_loc] <- "."  # replace old location with floor tile
  m[en_loc_new] <- "E"  # place enemy in new location

  m

}
```

### Put it all together

Now let's put the functions together. First, a reminder of the dungeon room with its minor obstacle:

```{r}
print_tiles(m)
```

Now we initiate the complementary distance map:

```{r}
d <- initiate_distance_map(m)
d
```

Then populate the distance values from the target:

```{r}
d <- populate_distance_map(m, d)
d
```

Success. You can see the player's tile at [7,3] scores 0 and emanates out to the right, around the obstacle, before wrapping back to the top-left and toward the enemy at position [3,3]. 

The enemy needs only to move to the neighbouring tile with the lowest distance score. So from 16 to 15 on either [4,3] or [3,4]. See how this time it won't get stuck trying to move south? The distance scores decrease from left to right before curving round the wall in the direction of the player's tile. 

For fun, we can print to the console an animation of the movement, which I've captured in gif form.

<details><summary>Click for R code</summary>
```{r eval=FALSE}
repeat {
  cat("\014")  # clear console
  m <- move_enemy(m, d)  # move enemy
  print_tiles(m)  # print to console
  Sys.sleep(0.5)  # wait
  if (!any(m == "@")) break  # stop if player captured
}
```
</details>

<div class="figure">
<img src="/post/2022-06-10-basic-search_files/pathfind.gif" alt="Animation of an R console, showing a rectangular grid of tiles that represents a dungeon room. Floor tiles are periods. Surrounding walls are hashmarks. There's an enemy character represented by a letter 'E' in the upper left, and a player character represented by an 'at' symbol in the lower left. There's an obstacle wall separating them. The enemy character moves tile by tile around the obstacle until it reaches the player." width="50%"/>
<p class="caption">Look it him go!</p>
</div>

You can see the enemy go round the wall and reach the player using a pretty efficient path.

# The end of the tunnel?

I've smashed this together quickly with some completely un-optimised code. Once I've ironed out some kinks, it'll go into [the {r.oguelike} package](https://github.com/matt-dray/r.oguelike) proper.

Of course, it'll need to take into account a moving player-character as well, so the distances map will need to be updated every turn.

Also, it might make sense to limit the range of the frontier to some specified distance away from the player, so that an enemy will only begin pathfinding when a player is closer and more 'detectable'.[^detect]

I think different enemy types should behave differently too. Maybe some could move randomly, or won't hone in on the player until they're very close by (e.g. when a few tiles away), while others are 'smarter' and begin encroaching immediately.

As a basic preview, here's what it looks like when you throw the pathfinding into [a procedurally-generated dungeon from {r.oguelike}](https://www.rostrum.blog/2022/05/01/dungeon/):

<div class="figure">
<img src="/post/2022-06-10-basic-search_files/pathfind-dungeon.gif" alt="Animation of an R console, showing a rectangular grid of tiles that represents a dungeon room. Floor tiles are periods. Surrounding walls are hashmarks. There's an enemy character represented by a letter 'E' in the lower left, and a player character represented by an 'at' symbol toward the right. There's some obstacle walls separating them. The enemy character moves tile by tile around the obstacle until it reaches the player." width="75%"/>
</div>

This gives a nice impression of the panic that might set in if you're down to 1 HP and a monster is chasing you into a dead-end. 

A quintessential roguelike 'feature'!

---
<details><summary>Session info</summary>
```{r sessioninfo, echo=FALSE}
sessioninfo::session_info()
```
</details>

[^implementation]: Perhaps unsurprisingly, there's not much on the web about implementing these algorithms in R for purposes of tile-based game development, specifically. There are implementations of theses algorithms, however, like [Michael Chow's A-star on GitHub](https://github.com/machow/astar-r), which could be adapted.
[^complicated]: Yes, there are cleverer ways to do this. More advanced techniques include [Dijkstra](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm), which allows for weighted edges (e.g. a 'cost' for travelling over terrain types), and [A-star](https://en.wikipedia.org/wiki/A*_search_algorithm), which uses a heuristic to improve the efficiency of finding the shortest path between two points. Learn more in sensational [introductions](https://www.redblobgames.com/pathfinding/a-star/introduction.html) and [implementations](https://www.redblobgames.com/pathfinding/a-star/implementation.html) on [Red Blob Games](https://www.redblobgames.com/) by [Amit Patel](https://twitter.com/redblobgames).
[^detect]: This behaviour probably makes more in-game sense. Unless you imagine the enemy has really great senses of smell or hearing and can detect the player wherever they are. Or your player character has just rolled low dexterity and is clumsy and loud.