---
title: Translate R to English with {r2eng}
author: Matt Dray
date: '2020-10-25'
slug: r2eng
categories:
  - package
tags:
  - accessibility
  - r
  - r2eng
draft: yes
---

# tl;dr



# Communication is hard

[Amelia McNamara](https://twitter.com/AmeliaMN) gave a talk at the useR! 2020 conference called 'Speaking R' ([YouTube](https://www.youtube.com/watch?v=ckW9sSdIVAc), [slides](https://www.amelia.mn/SpeakingR/#1)).

To summarise greatly: R code should be speakable so that we can teach, learn and communicate with minimal friction. Arguably this has never been more needed given the massive expansion of remote working this year.

By 'speakable' we mean that we should be able to map consistently each R code element to an English phrase. We should both understand exactly what we're talking about when discussing a script.

But that's easier said than... said.

The symbol that reads literally as percent-greater-than-percent, `%>%`, would be referred to by R users as a 'pipe'. But it's more complex than that: an R user may say the word 'then' when they're reading it in an expression. For example, `x %>% print()` might be vocalised as 'x then print'.

Naming symbols consistently is one challenge, but what about parsing entire expressions into English? Do you read the whole thing from left to right, or in some other way? Something as simple as `x <- 1` could be 'x gets 1', or 'assign 1 to the variable x', or something else entirely.

# Introducing {r2eng}

We might as well start somewhere.

Chung-hong Chan.

You can install the package from GitHub, which is in development version 0.0.0.9005 at the time of writing.

```{r install, eval=FALSE}
# Having installed {remotes}
remotes::install_github("matt-dray/r2eng")
```

It's likely to be in perpetual state of development and to be used as a way of furthering discussion on how we can make R speakable.

That said, it does do what it says on the tin for simple R expressions.

## Basic approach

{r2eng} is naive in its approach to translation.

It works on the basis of a one-to-one mapping between code and English. This means it has an opinionated set of English phrases that match to each token. You may not agree with the English terms used.

It also evaluates code on a left-to-right-basis. It has no awareness of the construction of a given R expression.

The secret sauce of the package is that it recognises the 'tokens' that make up an R expression before translation. In other words, the assignment operator is interpreted as the single token `<-`, rather than the two tokens 

## translate()

There are two main functions in {r2eng}: `translate()` and `translate_string()`. They translate to English text a bare or quoted R expression, respectively.

With `translate()` you pass bare R code to the `expression` argument and a few things happen.

```{r translate}
library(r2eng)
translate(data <- 1 + 1)
```

First, it prints both the original R expression and the corresponding English translation. Second, and only if you are using macOS, the English string is passed to a system command that vocalises the string.

The `translate_string()` takes an R expression as a string instead.

```{r translate-str}
library(magrittr)
"data<-1+1" %>%
  translate_string(speak = FALSE)
```

We get the same result, of course, but this time I set the `speak` argument to `FALSE` to stop the English text from being 'spoken' by my computer. I also eliminated spaces from the input to demonstrate that they're ignored.

## r2eng objects

Of course, you can assign a translation to an object.

```{r translate-obj}
my_translation <- 
  translate(data <- 1 + 1, speak = FALSE)
```

The object is a special `r2eng` S3 class of object, which is also a list.

```{r translate-obj-class}
class(my_translation)
```

You can apply some methods to such an object: `print()`, `speak()` and `evaluate()`.

Print the object to see that custom console output again:

```{r translate-obj-print}
print(my_translation)
```

Re-call the system command that 'speaks' the R expression out loud (again, only on macOS).

```{r translate-obj-speak}
speak(my_translation)
```

And you can actually evaluate the R expression you supplied to `translate()` in the first place. So the expression we supplied, `data <- 1 + 1`, is evaluated so that calling `data` gives us the result of `1 + 1`.

```{r translate-obj-eval}
evaluate(my_translation)
data
```

## List elements

You can also access the R expression, the English translation and the mapping between them as elements of your `r2eng` list object.

Here's the R expression again:

```{r translate-list-r}
my_translation$r_expression
```

And the translated output:

```{r translate-list-eng}
my_translation$eng_expression
```

And a `data.frame` object that contains the mapping (I've removed the blanks that indicate spaces).

```{r translate-list-map}
map <- my_translation$translation_map
map[map$text != "", ]
```

This element is a good summary of what {r2eng}'s is doing under the hood: it breaks the R expression into recognised tokens and maps words to them where it knows what the corresponding English for that token should be. So `<-` is recognised as the token `LEFT_ASSIGN`, which is mapped internally to the English text `gets`.

## Bonus functionality

### RStudio Addin

The `print()` and `speak()` functions can be accessed via an RStudio addin that's part of the package. Once installed, you can select R expressions in your script and select either:

* 'Speak R Expression In English' to vocalise it through your speakers
* 'Print R Expression In English' to output an English translation

These can be mapped to keyboard shortcuts so you can highlight and translate quickly without specifically calling `translate()` and `print()` or `speak()`.

### Binder demo

[![Launch Rstudio Binder](http://mybinder.org/badge_logo.svg)](https://mybinder.org/v2/gh/matt-dray/try-r2eng/master?urlpath=rstudio)

https://github.com/matt-dray/try-r2eng

# Plans

* Expanded list of translations
* Slightly less-opinionated English terms
* Full script awareness
* Speaking on non-Mac platforms
* Non-English languages