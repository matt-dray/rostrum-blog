---
title: "I can't be parsed, mate"
author: Matt Dray
date: '2023-02-28'
slug: getparsedata
categories:
  - code
  - tutorial
tags:
  - r
draft: yes
---



<div id="tldr" class="section level1">
<h1>tl;dr</h1>
<p>R is capable of reading R code. Obviously. You can use <code>getParseData()</code> to see what’s going on.</p>
</div>
<div id="static-prevails" class="section level1">
<h1>Static prevails</h1>
<p>This is handy for stuff like linters. These are programs that can detect the structure and content of some code without actually running it. They can be used to spot ugly code and make it prettier.</p>
<p>I’ve used this approach a few times to:</p>
<ul>
<li>insert a comment after a closing parenthesis (a so-called ‘biscuit’) to label it with the name of the function that it’s closing</li>
<li>identify files that contain equals assignment (<code>x = 1</code>), rather than an assignment arrow (<code>x &lt;- 1</code>)</li>
<li>match tokens against words so an expression can be translated to English (<code>&lt;-</code> is recognised as the token ‘LEFT_ASSIGN’ which we might call ‘gets’ in a translation of <code>x &lt;- 1</code> to ‘x gets 1’)</li>
</ul>
<p>I was never trained in computer science. You can argue that ‘writing R code’ is not ‘programming’ in a gatekeeping sense.</p>
</div>
<div id="parse-the-parcel" class="section level1">
<h1>Parse the parcel</h1>
<p>You can pass a string of R code to <code>parse()</code> for it to be converted to an ‘expression’ class. In other words, the string has been parsed as R code, but not yet evaluated.</p>
<pre class="r"><code>string &lt;- &quot;x &lt;- subset(beaver1, temp &lt; 36.4)&quot;
expression &lt;- parse(text = string)
expression</code></pre>
<pre><code>## expression(x &lt;- subset(beaver1, temp &lt; 36.4))</code></pre>
<p>A string is just a string. A captured expression is potent code.</p>
<p>When you’re ready, you can <code>eval()</code>uate the expression. As a result, the dataframe <code>x</code> is now in our environment and contains only rows of <code>beaver1</code> where body temperatures were less than 36.4.</p>
<pre class="r"><code>eval(expression)
x</code></pre>
<pre><code>##   day time  temp activ
## 1 346  840 36.33     0
## 2 346  850 36.34     0
## 3 346  900 36.35     0</code></pre>
<p>Wow, we have the power to delay code execution!</p>
<p>That’s great, but we actually froze in time the expression so we can pick it apart.</p>
<p>This is done with <code>getParseData()</code>, which identifies from an expression its ‘tokens’: its smallest, atomic units of code. These are returned in a dataframe with a row per token.</p>
<pre class="r"><code>getParseData(parse(text = string, keep.source = TRUE))</code></pre>
<pre><code>##    line1 col1 line2 col2 id parent                token terminal    text
## 25     1    1     1   33 25      0                 expr    FALSE        
## 1      1    1     1    1  1      3               SYMBOL     TRUE       x
## 3      1    1     1    1  3     25                 expr    FALSE        
## 2      1    3     1    4  2     25          LEFT_ASSIGN     TRUE      &lt;-
## 23     1    6     1   33 23     25                 expr    FALSE        
## 4      1    6     1   11  4      6 SYMBOL_FUNCTION_CALL     TRUE  subset
## 6      1    6     1   11  6     23                 expr    FALSE        
## 5      1   12     1   12  5     23                  &#39;(&#39;     TRUE       (
## 7      1   13     1   19  7      9               SYMBOL     TRUE beaver1
## 9      1   13     1   19  9     23                 expr    FALSE        
## 8      1   20     1   20  8     23                  &#39;,&#39;     TRUE       ,
## 19     1   22     1   32 19     23                 expr    FALSE        
## 13     1   22     1   25 13     15               SYMBOL     TRUE    temp
## 15     1   22     1   25 15     19                 expr    FALSE        
## 14     1   27     1   27 14     19                   LT     TRUE       &lt;
## 16     1   29     1   32 16     17            NUM_CONST     TRUE    36.4
## 17     1   29     1   32 17     19                 expr    FALSE        
## 18     1   33     1   33 18     23                  &#39;)&#39;     TRUE       )</code></pre>
<p>While presented as a dataframe, the information has actually been parsed as a tree-like structure. For example, note that each token is shown with the unique <code>id</code> of a <code>parent</code> token under which it sits.</p>
<p>Provided are columns giving the line and column location of each token, a unique identifier within the expression, the id of parent of the token, the special internal name for the type of token, whether it’s a ‘leaf’ node in the parse tree.</p>
<p>Note how tokens have been detected in context: <code>&lt;-</code> is recognised as the assignment arrow rather than a less-than and a hyphen, for example, while <code>subset</code> and <code>beaver1</code> are recognised as different types of token despite both being unquoted strings.</p>
<p>I’m going to write a little function that parses an R expression from a character string. First, it uses <code>parse()</code> to convert the R string to an ‘expression’, then extracts the ‘tokens’ from the parsed expression. Optionally you can remove the spaces, which aren’t that interesting to us anyway. I’ve called the function parsley, because it’s on the edge of being amusing.</p>
<pre class="r"><code>parsley &lt;- function(string, simplify = TRUE) {
  p &lt;- parse(text = string, keep.source = TRUE)
  pd &lt;- getParseData(p)
  if (simplify) {
    keep_cols &lt;- c(&quot;id&quot;, &quot;parent&quot;, &quot;token&quot;, &quot;text&quot;)
    pd &lt;- pd[pd$text != &quot;&quot;, keep_cols]
  }
  pd
}</code></pre>
<p>Just to prove that R can recognise a string as an R expression, you can <code>parse()</code> a string containing R code and then <code>eval()</code>uate it:</p>
<pre class="r"><code>code &lt;- &quot;mtcars[mtcars$cyl == 4, ] |&gt; head()&quot;
eval(parse(text = code))</code></pre>
<pre><code>##                 mpg cyl  disp hp drat    wt  qsec vs am gear carb
## Datsun 710     22.8   4 108.0 93 3.85 2.320 18.61  1  1    4    1
## Merc 240D      24.4   4 146.7 62 3.69 3.190 20.00  1  0    4    2
## Merc 230       22.8   4 140.8 95 3.92 3.150 22.90  1  0    4    2
## Fiat 128       32.4   4  78.7 66 4.08 2.200 19.47  1  1    4    1
## Honda Civic    30.4   4  75.7 52 4.93 1.615 18.52  1  1    4    2
## Toyota Corolla 33.9   4  71.1 65 4.22 1.835 19.90  1  1    4    1</code></pre>
<p>Our cheeky little parsing function does this step and then also extracts all the tokens:</p>
<pre class="r"><code>parsley(code, simplify = FALSE)</code></pre>
<pre><code>##    line1 col1 line2 col2 id parent                token terminal   text
## 28     1    1     1   35 28      0                 expr    FALSE       
## 19     1    1     1   25 19     28                 expr    FALSE       
## 1      1    1     1    6  1      3               SYMBOL     TRUE mtcars
## 3      1    1     1    6  3     19                 expr    FALSE       
## 2      1    7     1    7  2     19                  &#39;[&#39;     TRUE      [
## 13     1    8     1   22 13     19                 expr    FALSE       
## 8      1    8     1   17  8     13                 expr    FALSE       
## 4      1    8     1   13  4      6               SYMBOL     TRUE mtcars
## 6      1    8     1   13  6      8                 expr    FALSE       
## 5      1   14     1   14  5      8                  &#39;$&#39;     TRUE      $
## 7      1   15     1   17  7      8               SYMBOL     TRUE    cyl
## 9      1   19     1   20  9     13                   EQ     TRUE     ==
## 10     1   22     1   22 10     11            NUM_CONST     TRUE      4
## 11     1   22     1   22 11     13                 expr    FALSE       
## 12     1   23     1   23 12     19                  &#39;,&#39;     TRUE      ,
## 17     1   25     1   25 17     19                  &#39;]&#39;     TRUE      ]
## 20     1   27     1   28 20     28                 PIPE     TRUE     |&gt;
## 26     1   30     1   35 26     28                 expr    FALSE       
## 21     1   30     1   33 21     23 SYMBOL_FUNCTION_CALL     TRUE   head
## 23     1   30     1   33 23     26                 expr    FALSE       
## 22     1   34     1   34 22     26                  &#39;(&#39;     TRUE      (
## 24     1   35     1   35 24     26                  &#39;)&#39;     TRUE      )</code></pre>
<p>You’ll notice that there’s a kind of nesting explained by these columns. Note how the square brackets and the comma are under the same ‘parent’.</p>
<pre class="r"><code>lobstr::ast(
  mtcars[mtcars$cyl == 4, ] |&gt; head()
)</code></pre>
<pre><code>## █─head 
## └─█─`[` 
##   ├─mtcars 
##   ├─█─`==` 
##   │ ├─█─`$` 
##   │ │ ├─mtcars 
##   │ │ └─cyl 
##   │ └─4 
##   └─``</code></pre>
<p>You might be wondering where’s the pipe (<code>|&gt;</code>) gone? In short, the R parser recognises and evaluates a string like <code>mtcars |&gt; head()</code> literally as <code>head(mtcars)</code>. Compare this to <code>lobstr::ast(mtcars %&gt;% head)</code>, where <code>%&gt;%</code> is actually a function that is evaluated more like `<code>%&gt;%`(mtcars, head)</code>.</p>
<p>You may also be wondering what is meant by <code>[</code> being presented a level above <code>mtcars</code> and why there’s no matching closing bracket? Or why <code>[</code>, <code>==</code> and <code>$</code> are all being presented with backticks around them? Well, like everything in R, these are all actually functions. See how these two things are equivalent?</p>
<pre class="r"><code>normal  &lt;- mtcars[mtcars$cyl == 4, ] |&gt; head()
bonkers &lt;- head(`[`(mtcars, `==`(`$`(mtcars, cyl), 4), ))
all(normal == bonkers)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<hr />
<details>
<summary>
Session info
</summary>
<pre><code>## ─ Session info ───────────────────────────────────────────────────────────────
##  setting  value
##  version  R version 4.2.0 (2022-04-22)
##  os       macOS Big Sur/Monterey 10.16
##  system   x86_64, darwin17.0
##  ui       X11
##  language (EN)
##  collate  en_US.UTF-8
##  ctype    en_US.UTF-8
##  tz       Europe/London
##  date     2023-03-01
##  pandoc   2.19.2 @ /Applications/RStudio.app/Contents/Resources/app/quarto/bin/tools/ (via rmarkdown)
## 
## ─ Packages ───────────────────────────────────────────────────────────────────
##  package     * version date (UTC) lib source
##  blogdown      1.9     2022-03-28 [1] CRAN (R 4.2.0)
##  bookdown      0.26    2022-04-15 [1] CRAN (R 4.2.0)
##  bslib         0.3.1   2021-10-06 [1] CRAN (R 4.2.0)
##  cli           3.6.0   2023-01-09 [1] CRAN (R 4.2.0)
##  crayon        1.5.2   2022-09-29 [1] CRAN (R 4.2.0)
##  digest        0.6.31  2022-12-11 [1] CRAN (R 4.2.0)
##  evaluate      0.20    2023-01-17 [1] CRAN (R 4.2.0)
##  fastmap       1.1.0   2021-01-25 [1] CRAN (R 4.2.0)
##  htmltools     0.5.2   2021-08-25 [1] CRAN (R 4.2.0)
##  jquerylib     0.1.4   2021-04-26 [1] CRAN (R 4.2.0)
##  jsonlite      1.8.4   2022-12-06 [1] CRAN (R 4.2.0)
##  knitr         1.42    2023-01-25 [1] CRAN (R 4.2.0)
##  lobstr        1.1.2   2022-06-22 [1] CRAN (R 4.2.0)
##  R6            2.5.1   2021-08-19 [1] CRAN (R 4.2.0)
##  rlang         1.0.6   2022-09-24 [1] CRAN (R 4.2.0)
##  rmarkdown     2.14    2022-04-25 [1] CRAN (R 4.2.0)
##  rstudioapi    0.14    2022-08-22 [1] CRAN (R 4.2.0)
##  sass          0.4.1   2022-03-23 [1] CRAN (R 4.2.0)
##  sessioninfo   1.2.2   2021-12-06 [1] CRAN (R 4.2.0)
##  xfun          0.37    2023-01-31 [1] CRAN (R 4.2.0)
##  yaml          2.3.7   2023-01-23 [1] CRAN (R 4.2.0)
## 
##  [1] /Library/Frameworks/R.framework/Versions/4.2/Resources/library
## 
## ──────────────────────────────────────────────────────────────────────────────</code></pre>
</details>
</div>
