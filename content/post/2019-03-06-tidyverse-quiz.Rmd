---
title: "Quiz: do you know tidyverse functions?"
author: Matt Dray
date: '2019-03-06'
slug: tidyverse-quiz
categories:
  - R
tags:
  - quiz
  - learnr
  - tidyverse
  - pacman
draft: yes
---

Matt Dray ([\@mattdray](https://www.twitter.com/mattdray))

![](https://raw.githubusercontent.com/matt-dray/tidyverse-quiz/master/images/tidyverse_quiz.gif)

# TL;DR

I made [{tidyquiz}](https://github.com/matt-dray/tidyquiz): a package containing a (niche) multiple-choice quiz to test your ability to match tidyverse functions to their packages. To use it:

1. Install the package with `remotes::install_github("matt-dray/tidyquiz")`
1. Call the package with `library(tidyquiz)`
1. Run `learnr::run_tutorial("tidy", package = "tidyquiz")` to open in your browser

# The problem

I saw a (probably) tongue-in-cheek tweet recently from [Ryan Timpe](https://twitter.com/ryantimpe):

<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">Hardest part about <a href="https://twitter.com/hashtag/rstats?src=hash&amp;ref_src=twsrc%5Etfw">#rstats</a> package development: remembering which functions are from {dplyr} and which are from {tidyr}.</p>&mdash; Ryan Timpe ðŸ¦–ðŸ“Š (@ryantimpe) <a href="https://twitter.com/ryantimpe/status/1102666979909996545?ref_src=twsrc%5Etfw">March 4, 2019</a></blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

Is the purpose of each package in [the tidyverse](https://www.tidyverse.org/) clear enough?

Many users will get around this by running `library(tidyverse)`, which installs the core set of eight tidyverse packages. You can run `select()` or `gather()` after that without having to think about whether they're part of {dplyr} or {tidyr}.

This made me wonder how good I was at remembering which functions (or previously unseen functions) belong to which packages in the tidyverse. So naturally I thought it would be a fun diversion to test myself. i also wanted to see whether functions in the {learnr} package could help me do it.

# Step 0: the approach

I wanted:

1. to get all the package-function combos in the tidyverse
1. a user to be presented with an interactive question about a tidyverse function
1. the ability to generate a new question from within the document

These are solved by using the functions `tidyverse::tidyverse_packages()` and `pacman::p_functions()`; {learnr}'s solution for interactive multiple-choice questions in an R Markdown document; and a dollop of additional Shiny, which can operate in the Shiny-runtime of the R Markdown. The sections below go into this in more detail.

# Step 1: package-function combos

You can see the {tidyverse} package only loads the eight core packages by default.

```{r tidyverse, warning=FALSE}
library(tidyverse)
```

Fortunately there's a function that provides the names of all the packages within the tidyverse.

```{r tidyverse_packages}
tidy_pkgs <- tidyverse_packages() %>%  # calls character vector
  # We can protect ourselves from any rogue characters in this vector
  str_replace("\n", "") %>%  # remove newline
  str_replace(">=", "") %>%  # remove greater than or equal to
  str_replace("[:punct:]", "")  # remove punctuation

tidy_pkgs
```

We can pass this character vector to {pacman}'s `p_load()` to install and load them all.

```{r p-load, warning=FALSE}
library(pacman)

p_load(
  char = tidy_pkgs,
  character.only = TRUE  # read elements of character vector
)
```

Now we can get the functions from each package by mapping over each with {pacman}'s `p_functions()`.

```{r tidy-funs}
tidy_funs <- tidy_pkgs %>% 
  enframe(name = NULL, value = "package") %>%  # make tibble
  mutate(
    functions = map(
      package,  # for each package name...
      ~p_functions(.x, character.only = TRUE)  # ...get functions
    )
  ) %>% 
  unnest()  # unpack the listcol elements
```

Here's a small sample:

```{r tidy-funs-sample}
sample_n(tidy_funs, 10)  # random sample
```

Out of interest we can look at the packages with the most and fewest functions:

```{r tidy_funs}
most_pkgs <- group_by(tidy_funs, package) %>% count()

arrange(most_pkgs, desc(n))
arrange(most_pkgs, n)
```

Great. How we can turn this into an interactive multiple-choice question?

# Step 2: interactive questions with {learnr}

The [{learnr} package](https://rstudio.github.io/learnr/) helps you turn an R Markdown document into an interactive tutorial with a little help from Shiny. You can do things like embed exercises that allow the user to execute code to test their knowledge. It also has a function to create multiple-choice questions, which is exactly what we need.

Having installed the package and [started a {learnr}-flavoured R Markdown](https://rstudio.github.io/learnr/#getting_started) we can create a question inside a code chunk in this form:

```{r fake-question, eval=FALSE}
quiz(
  caption = "Question 1",
  question(
    text = "What is Pokemon #399?",  # question
    answer("Bidoof"), correct = TRUE),  # right answer
    answer("Drifloom"),   # wrong
    answer("Pyukumuku"),  # wrong
    answer("Rayquaza"),   # wrong
    random_answer_order = TRUE  # answers ordered randomly
  )
)
```

Notice that this example is hardcoded. This is fine in a regular tutorial, but in our case we want to replace the subject of the question and the answers whenever we sample a new tidyverse function.

Since {learnr} operates in a Shiny runtime in our R Markdown file anyway, we can create a Shiny button that a user can click to generate a new question.

# Step 3: generate questions with Shiny

Rather than generate a random question when a button is pressed, the user inputs a value that will be used in the `set.seed()` function and presses 'Go'. This function makes sampling repeatable. In other words, the user will get the same question if they use the same seed. This lets people return to, or share, particularly tricky questions.

```{r, shiny-button, eval=FALSE}
numericInput("n", "Set seed:", value = 1337)
actionButton("goButton", "Go")
```

We can then ensure that triggering the action button forces rendering of the text that will make up the question and the answers.

This example is for constructing the question to include the randomly-selected function. We repeat this for the correct answer and for three wrong answers.

```{r, shiny-reactive, eval=FALSE}
# This takes place in an R Markdown chunk with
# context="server" in the chunk options

# Set the reactive element
fun_name <- eventReactive(
  input$goButton,  # on input
  { 
    set.seed(input$n)  # put the input value in set.seed()
    fun_sample <- sample_n(tidy_funs, 1)  # sample a package-function combo
    fun_name <- select(fun_sample, functions) %>% pull()  # just the function
    return(fun_name)  # return the package value
  }
)

# Set the output
# Generate a question that includes the sampled function name 
output$fun_name_out <- renderText({
  paste0("The function `", fun_name(), "` is from which tidyverse package?")
})
```

So rather than the hardcoded example of a multi-choice question in Step 2, we have something like this instead:

```{r, reactive-question, eval=FALSE}
quiz(
  caption = "Question ",
  question(
    text = as.character(textOutput("fun_name_out")),
    answer(as.character(textOutput("ans_correct_out")), correct = TRUE),
    answer(as.character(textOutput("ans_wrong1_out"))),
    answer(as.character(textOutput("ans_wrong2_out"))),
    answer(as.character(textOutput("ans_wrong3_out"))),
    random_answer_order = TRUE
  )
)
```

So now the text outputs will be rendered into the quiz question. Since these are reactive, it means they won't change until the 'Go' button is clicked.

Browse the code [on GitHub](https://github.com/matt-dray/tidyquiz) and [leave an issue](https://github.com/matt-dray/tidyquiz/issues) with thoughts or suggestions.