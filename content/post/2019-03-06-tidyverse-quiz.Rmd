---
title: "A tidyverse functions quiz with {learnr}"
author: Matt Dray
date: '2019-03-06'
slug: tidyverse-quiz
categories:
  - R
tags:
  - quiz
  - learnr
  - tidyverse
  - pacman
draft: no
---

Matt Dray ([\@mattdray](https://www.twitter.com/mattdray))

![](https://raw.githubusercontent.com/matt-dray/tidyverse-quiz/master/images/tidyverse_quiz.gif)

# TL;DR

I made [{tidyquiz}](https://github.com/matt-dray/tidyquiz): a very simple package containing a simple (niche) multiple-choice quiz to test your ability to match tidyverse functions to their packages. To use it:

1. Install the package with `remotes::install_github("matt-dray/tidyquiz")`
1. Call the package with `library(tidyquiz)`
1. Run `learnr::run_tutorial("tidy", package = "tidyquiz")` to open in your browser

# The problem

I saw a (probably) tongue-in-cheek tweet recently from [Ryan Timpe](https://twitter.com/ryantimpe):

<blockquote class="twitter-tweet" data-lang="en"><p lang="en" dir="ltr">Hardest part about <a href="https://twitter.com/hashtag/rstats?src=hash&amp;ref_src=twsrc%5Etfw">#rstats</a> package development: remembering which functions are from {dplyr} and which are from {tidyr}.</p>&mdash; Ryan Timpe ðŸ¦–ðŸ“Š (@ryantimpe) <a href="https://twitter.com/ryantimpe/status/1102666979909996545?ref_src=twsrc%5Etfw">March 4, 2019</a></blockquote>
<script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>

Is the purpose of each package in [the tidyverse](https://www.tidyverse.org/) clear enough? Or are they [too arbitrary](https://twitter.com/dnlmc/status/1105973896828866560)? Maybe it doesn't matter if you load {tidyverse}, which in turn loads a bunch of other packages.[^load-all]

This made me wonder how good I am at remembering which functions (or previously unseen functions) belong to which packages. A good chance to play with the {learnr} package.

# Step 0: the approach

I wanted:

1. To get a tidy dataframe of all the package-function combos in the tidyverse -- `tidyverse::tidyverse_packages()` does this
1. A user to be presented with an interactive question about one of these tidyverse functions -- {learnr} does this
1. The ability to generate a new question from within the document -- a reactive Shiny button does this

# Step 1: package-function combos

You can see the {tidyverse} package only loads the eight core packages by default.

```{r tidyverse, warning=FALSE}
library(tidyverse)
```

Fortunately there's a function that provides the names of all the packages within the tidyverse.

```{r tidyverse_packages}
tidy_pkgs <- tidyverse_packages() %>%  # calls character vector
  # We can protect ourselves from any rogue characters in this vector
  str_replace("\n", "") %>%  # remove newline
  str_replace(">=", "") %>%  # remove greater than or equal to
  str_replace("[:punct:]", "")  # remove punctuation

tidy_pkgs
```

We can pass this character vector to {pacman}'s `p_load()` to install and load them all.

```{r p-load, warning=FALSE}
library(pacman)

p_load(
  char = tidy_pkgs,
  character.only = TRUE  # read elements of character vector
)
```

Now we can get the functions from each package by mapping over each with {pacman}'s `p_functions()`.

```{r tidy-funs}
tidy_funs <- tidy_pkgs %>% 
  enframe(name = NULL, value = "package") %>%  # make tibble
  mutate(
    functions = map(
      package,  # for each package name...
      ~p_functions(.x, character.only = TRUE)  # ...get functions
    )
  ) %>% 
  unnest()  # unpack the listcol elements
```

Here's a small sample:

```{r tidy-funs-sample}
sample_n(tidy_funs, 10)  # random sample
```

Out of interest we can look at the packages with the most and fewest functions:

```{r tidy_funs}
most_pkgs <- group_by(tidy_funs, package) %>% count()

arrange(most_pkgs, desc(n))
arrange(most_pkgs, n)
```

Great. How we can turn this into an interactive multiple-choice question?

# Step 2: interactive questions with {learnr}

The [{learnr} package](https://rstudio.github.io/learnr/) helps you turn an R Markdown document into an interactive tutorial with a little help from Shiny. You can uae it to embed exercises in an R Markdown document so you can test the reader's knowledge. One option is to create a multiple-choice question, which is exactly what we need.

Having installed the package and [started a {learnr}-flavoured R Markdown](https://rstudio.github.io/learnr/#getting_started)[^learnr-rmd] we can create a multiple-choice question inside a code chunk in this form:

```{r fake-question, eval=FALSE}
quiz(
  caption = "Question 1",
  question(
    text = "What is Pokemon #399?",  # question
    answer("Bidoof"), correct = TRUE),  # right answer
    answer("Drifloom"),   # wrong
    answer("Pyukumuku"),  # wrong
    answer("Rayquaza"),   # wrong
    random_answer_order = TRUE  # answers ordered randomly
  )
)
```

Notice that this example is hardcoded. This is fine in a regular tutorial, but in our case we want to replace the subject of the question and the answers whenever we sample a new tidyverse function.

Since {learnr} operates in a Shiny runtime in our R Markdown file, we can create a reactive Shiny button that a user can click to generate a new question.

# Step 3: generate new questions with Shiny

Rather than generate a random question when a button is pressed, the user inputs a value that will be used in the `set.seed()` function and presses 'Go'. This function makes sampling repeatable. In other words, the user will get the same question if they use the same seed. This lets people return to, or share, particularly tricky questions. The input and button code would look like this:

```{r, shiny-button, eval=FALSE}
numericInput("n", "Set seed:", value = 1337)
actionButton("goButton", "Go")
```

Then we need to create some Shiny server code within an R Markdown chunk, which we do by setting `context="server"` in the chunk options. This example shows how we might generate the question text. First, it samples a row from the full dataframe of package-function combos and isolates the function name that will be the ubjetc of the question. This code is within `eventReactive()` and will only trigger when the button has been activated. Second, we use `renderText()` to take the function name and paste it into a question. 

```{r, shiny-reactive, eval=FALSE}
# Set the reactive element
fun_name <- eventReactive(
  input$goButton,  # on input
  { 
    set.seed(input$n)  # put the user's input value into set.seed()
    fun_sample <- sample_n(tidy_funs, 1)  # sample a package-function combo
    fun_name <- select(fun_sample, functions) %>% pull()  # get the function name
    return(fun_name)  # return the package value
  }
)

# Set the output
# Generate a question that includes the sampled function name 
output$fun_name_out <- renderText({
  paste0("The function `", fun_name(), "` is from which tidyverse package?")
})
```

We can repeat this for getting the tight answer and some wrong answers. A 'wrong' answer is selected randomly once the correct answer has been removed. I've also coded it so that any package that has a function with the same name -- a conflict -- will also be removed before a 'wrong' answer is chosen. 

So rather than the hardcoded example of a multi-choice question in Step 2, our quiz question code will look like this:

```{r, reactive-question, eval=FALSE}
quiz(
  caption = "Question ",
  question(
    text = as.character(textOutput("fun_name_out")),
    answer(as.character(textOutput("ans_correct_out")), correct = TRUE),
    answer(as.character(textOutput("ans_wrong1_out"))),
    answer(as.character(textOutput("ans_wrong2_out"))),
    answer(as.character(textOutput("ans_wrong3_out"))),
    random_answer_order = TRUE
  )
)
```

So now the text outputs will be rendered into the quiz question. Since these are reactive, it means they won't change until the 'Go' button is clicked.

# Get the code

Browse the code [on GitHub](https://github.com/matt-dray/tidyquiz) and [leave an issue](https://github.com/matt-dray/tidyquiz/issues) with thoughts or suggestions.

[^load-all]: You can run `select()` or `gather()` after this without having to think about whether they're part of {dplyr} or {tidyr}. I prefer personally to load only the packages I need.
[^learnr-rmd]: After installing {learnr} you can go to new R Markdown > From Template > Interactive Tutorial.