---
title: 'Can {drake} RAP?'
author: Matt Dray
date: '2019-06-10'
slug: drake-lays-an-egg
categories:
  - R
tags:
  - reproducibility
  - drake
  - eggs
  - rap
  - reproducible analytical pipelines
  - make
  - make file
draft: yes
---

# tl;dr

The [{drake}](https://github.com/ropensci/drake) package records file interdependecies in your analysis. When files are changed, {drake} only re-runs the parts of your analysis that need to be re-run.

# Make it to make it

Analysis projects can become complicated as multiple inputs, script files and outputs build up.

You'll need to re-run your code if any file edits are made. Can you remember exactly which scripts need to be re-executed? Or will you have to re-run the entire project from scratch? This is especially tedious in a large project.

A ['makefile'](https://en.wikipedia.org/wiki/Makefile) can help you. In short, it's a text file in which you write each step of your analysis in a recipe-like format. Dependencies between data, code and outputs are recorded.

Now when something changes, only the affected file and those downstream from it will be re-executed. This saves compute time and means you don't have to remember any dependencies yourself.

# {drake} it to make it

[{drake}](https://github.com/ropensci/drake) is a package by [Will Landau](https://wlandau.github.io/) that gives you makefiles with R syntax. The project is part of [rOpenSci](https://ropensci.org/), which seeks to make tools for scientific computing more open.

With {drake} you prepare a R script 'plan' that records all the functions to be executed. You then 'make' the plan to build the project from scratch or tore-run the outdated steps.

This post contains a very simple example of {drake} in action, but there's so much more to it. Fortunately, there's lots of resources:

* [user manual](https://ropenscilabs.github.io/drake-manual/)
* [documentation](https://ropensci.github.io/drake/)
* [cheat sheet](https://github.com/krlmlr/drake-sib-zurich/blob/master/cheat-sheet.pdf) by [Kirill Müller](https://twitter.com/krlmlr)
* ['drake for workflow happiness'](https://aedobbyn.github.io/nyc-fires/index.html#1) slides by [Amanda Dobbyn](https://dobb.ae/) -- which really embraces the [Drake meme]()

# Eggsample

Why do I care about {drake}?

I think there's potential for using it in [Reproducible Analytical Pipelines](https://ukgovdatascience.github.io/rap-website/) (RAP). RAP is a wholly code-based method for generating [statistical reports in the UK government](https://www.gov.uk/search/research-and-statistics) to improve reproducibility and automation, while minimising errors and speeding-up production. RAP projects can be large and things can change during development, so {drake} could be a good fit.

I've made a very simple {drake} demo for an imaginary RAP project. The demo recreates a very small part of a [statistical publication that tracks UK egg production](https://www.gov.uk/government/statistics/egg-statistics)[^egg].

The code is on [GitHub](https://github.com/matt-dray/drake-egg-rap), along with an [HTML version of the demo report](https://matt-dray.github.io/drake-egg-rap/egg-report.html). The rest of this post describes the contents of the repo.

I've broken my explanation into five steps below:

1. [Prepare R scripts](#prep)
2. [Load the scripts](#source)
3. [Visualise](#viz)
4. [Make the plan](#make)
5. [Make a change](#change)

## 1. Prepare the scripts {#prep}

The [demo repo](https://github.com/matt-dray/drake-egg-rap) contains [a folder](https://github.com/matt-dray/drake-egg-rap/tree/master/R) with three simple scripts[^scripts] that contain the code needed for our analysis. 

1. [`packages.R`](https://github.com/matt-dray/drake-egg-rap/blob/master/R/packages.R) loads the packages we need for our analysis with `library()`
1. [`functions.R`](https://github.com/matt-dray/drake-egg-rap/blob/master/R/functions.R) contains our own custom functions
1. [`plan.R`](https://github.com/matt-dray/drake-egg-rap/blob/master/R/plan.R) is where all the steps of the analysis are written

These are all thigs you'll find in a regular R analysis project.

The `plan.R` file needs a little more explanation. It contains the `drake_plan()` function, to which you pass the functions that make up your analysis. Our example plan is very simple, with only four functions:

```{r eval=FALSE}
egg_plan <- drake_plan(  # Create a drake_plan object called egg_plan
  
  # 1. Read the dataset
  raw_data = read_ods(
    path = "data/eggs-packers-02may19a.ods",
    sheet = "Packers_Annual",
    skip = 8
  ),  # separate each function with a comma
  
  # 2. Prepare the data with a bespoke function
  # from the functions.R file
  data = clean_data(raw_data),
  
  # 3. Generate a plot using a bespoke function
  # from the functions.R file
  plot = create_plot(data),
  
  # 4. Finally, render the R Markdown report
  # drake::knitr_in() marks the .Rmd file as a dependency
  # drake::file_out() marks the .HTML as an output
  report = rmarkdown::render(
    knitr_in("egg-report.Rmd"),
    output_file = file_out("docs/egg-report.html"),
    quiet = TRUE
  )

)
```

You can put the functions in any order; {drake} takes care of the dependencies and works out which order in which to run them.

So now we've got everything we need: our packages, functions and the plan. How do we execute the plan? We can use a [a small file called `make.R`](https://github.com/matt-dray/drake-egg-rap/blob/master/make.R) that brings everything together. 

## 2. Load the scripts {#source}

`make.R` starts with calls to `source()` each R script:

```{r eval=FALSE}
source(packages.R)  # load the packages
source(functions.R)  # load the bespoke functions
source(plan.R)  # load the plan
```

Sourcing the plan file means that the `drake_plan()` function inside is run, with the output being a data frame object[^df] called `egg_plan` in our example. It has columns called 'target' and 'command' and a row for each function in our analysis:

```{r eval=FALSE}
egg_plan
```
```{r eval=FALSE}
# A tibble: 4 x 2
  target   command                                                                           
  <chr>    <expr>                                                                            
1 raw_data read_ods(path = "data/eggs-packers-02may19a.ods", sheet = "Packers_Annual",      …
2 data     clean_data(raw_data)                                                             …
3 plot     create_plot(data)                                                                …
4 report   render(knitr_in("egg-report.Rmd"), output_file = file_out("docs/egg-report.html")…
```

The plan object acts like an instruction booklet, which can be read 'to each target, apply the named command'. My simple example has only four instructions:

1. Read the raw data (the target) with `readODS::read_ods()` (the command)
1. Clean the data (target) with our `clean_data()` function (command)
1. Plot the data (target) with our `plot_data()` function (command)
1. Create an R Markdown report (target) with `rmarkdown::render()` (command)

Before we execute this plan, we can take a look at what a dependency graph of these targets looks like.

## 3. Visualise {#viz}

Having created the `egg_plan` object, we can extract information about it to a configuration ('config') list object. One element of the config is, for example, an [igraph](https://igraph.org/) object that helps construct graphs from your workflow.

```{r eval=FALSE}
egg_config <- drake_config(egg_plan)
```

A number of {drake} functions can take the config object and do something with the information inside it. In our case, we're going to pass the config to `vis_drake_graph()`, which builds an interactive dependency graph based on {visNetwork}.

```{r eval=FALSE}
vis_drake_graph(egg_config)
```

[The interactive output](https://matt-dray.github.io/drake-egg-rap/dependency-graph.html) is handy for seeing dependencies at a glance. It's shape-coded to show the target type (object, function, file) and colour-coded to show whether everything is up-to-date. At the moment it tells us that nothing is outdated; since we haven't actually run the plan yet.

## 4. Make the plan {#make}

Running the plan is as simple as:

```{r eval=FALSE}
make(plan)
```

This runs all the instructions laid out in the `plan` object; all the commands are run on the corresponding targets. In our case, this outputs an HTML report, since the last step of the plan was to render an R Markdown file.

Of course, re-running the plan straight away again does... nothing. No code needs to be re-executed if nothing's changed! Remember that {drake} will identify changes for you and re-execute only the dependent parts.

## 5. Make a change {#change}

So if anything at all changes in our data or code then the downstream targets will be out of sync. Let's pretend we've changed a line of code in the `create_plot()` function, perhaps to alter its title. What do you think will happen?

Well, {drake} knows there's been a change! Running `outdated(egg_config)` prints the file that's been altered, plus all the impacted files that depend on it.

If we [take another look at the visualisation now](https://matt-dray.github.io/drake-egg-rap/dependency-graph-outdated.html), we can see that certain targets have been recoloured to show that they're out of date.

Re-running the plan will now cause these targets to be regenerated. Targets that aren't impacted by the change won't be re-run.

Where are the targets stored that didn't need to be recreated? Turns out that {drake} creates a `.drake/` folder to caches these objects and grabs then when needed. 

Items can be pulled from this cache by the user with the the `loadd()` and `readd()` functions. For example, the R Markdown report in my example simply calls the rendered plot object from the cache using `readd()`. This can help keep the R Markdown file less cluttered and more readable.

# In review

This post has shown how {drake}:

* remembers the dependencies between the files of your analysis
* only re-run what needs to be re-run

Of course, [{drake} does a lot more than this](https://ropenscilabs.github.io/drake-manual/), but even this is enough help public servants to manage statistical reports that are more reliable and trustworthy.


[^egg]: This publication could be a good candidate for RAP: content remains fairly similar between quarterly releases and it's required to meet high standards of quality because it's badged as [National Statistics](https://www.statisticsauthority.gov.uk/osr/list-of-national-statistics/).
[^scripts]: You don't have to restrict yourself to this configuration of scripts, but it can make it easier to handle your project.
[^df]: It actually has multiple classes: `drake_plan`, `tbl_df`, `tbl` and `data.frame`.