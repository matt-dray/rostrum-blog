---
title: 'Can {drake} RAP?'
author: Matt Dray
date: '2019-06-10'
slug: drake-lays-an-egg
categories:
  - R
tags:
  - reproducibility
  - drake
  - eggs
  - rap
  - reproducible analytical pipelines
  - make
  - make file
draft: yes
---

# tl;dr

The [{drake}](https://github.com/ropensci/drake) package remembers file interdependecies in your analysis and identifies what gets outdated so you don't have to. It only re-runs the parts of your analysis that need to be re-run.

# Make

Analysis projects can become complicated as multiple inputs, script files and outputs build up.

You need to re-run code if any changes are made. Can you remember exactly which bits of code need to be re-run? Or will you have to re-run everything from scratch? The latter is especially tedious in a large project.

A ['makefile'](https://en.wikipedia.org/wiki/Makefile) can help you. In short, it's a text file in which you write each step of your analysis in a recipe-like format. Dependencies between data, code and outputs are recorded.

Now when something changes, only the impacted steps will be re-executed. This saves compute time and means you don't have to remember any dependencies yourself.

# {drake} it to make it

[{drake}](https://github.com/ropensci/drake) is a package by [Will Landau](https://wlandau.github.io/) that lets you have all the benefits of makefiles, but with R syntax. It's part of [rOpenSci](https://ropensci.org/), which seeks to make tools for scientific computing more open.

With {drake} you prepare a R script 'plan' that records all the functions to be executed. You then 'make' the plan to run all the steps of the analysis.

This post contains a very simple example, but there's lots of helpful material to dig further into {drake}:

* [user manual](https://ropenscilabs.github.io/drake-manual/)
* [documentation](https://ropensci.github.io/drake/)
* [cheat sheet](https://github.com/krlmlr/drake-sib-zurich/blob/master/cheat-sheet.pdf) by [Kirill Müller](https://twitter.com/krlmlr)
* ['drake for workflow happiness'](https://aedobbyn.github.io/nyc-fires/index.html#1) slides by [Amanda Dobbyn](https://dobb.ae/)

# Eggsample

I think there's potential for using {drake} in [Reproducible Analytical Pipelines](https://ukgovdatascience.github.io/rap-website/) (RAP). RAP is a wholly code-based method for generating [statistical reports in the UK government](https://www.gov.uk/search/research-and-statistics) to improve things like reproducibility, automation, error minimisation and speed of production.

RAP projects can be large and things can change during development, so {drake} could be a good fit.

I've made a very simple {drake} demo for an imaginary RAP project. The demo recreates a very small part of a [statistical publication that tracks UK egg production](https://www.gov.uk/government/statistics/egg-statistics)[^egg].

The code is on [GitHub](https://github.com/matt-dray/drake-egg-rap), along with an [HTML version of the demo report](https://matt-dray.github.io/drake-egg-rap/egg-report.html). The rest of this post describes the contents of the repo.

## A cunning plan

The [repo](https://github.com/matt-dray/drake-egg-rap) contains [a folder](https://github.com/matt-dray/drake-egg-rap/tree/master/R) with three simple but important scripts[^scripts]:

1. [`packages.R`](https://github.com/matt-dray/drake-egg-rap/blob/master/R/packages.R) loads the packages we need for analysis using calls to `library()`
1. [`functions.R`](https://github.com/matt-dray/drake-egg-rap/blob/master/R/functions.R) contains bespoke functions
1. [`plan.R`](https://github.com/matt-dray/drake-egg-rap/blob/master/R/plan.R) is the recipe document that brings everything together

The `plan.R` file needs a little more explanation. It contains `drake::drake_plan()`, inside which you pass the functions that make up your analysis. Our example plan is very simple, with only four functions:

```{r eval=FALSE}
plan <- drake_plan(
  
  # read the datset
  raw_data = read_ods(
    path = "data/eggs-packers-02may19a.ods",
    sheet = "Packers_Annual",
    skip = 8
  ),  # separate each function with a comma
  
  # Prepare the data with a bespoke function
  # from the functions.R file
  data = clean_data(raw_data),
  
  # Generate a plot using a bespoke function
  # from the functions.R file
  plot = create_plot(data),
  
  # Finally, render the R Markdown report
  # drake::knitr_in() marks the .Rmd file as a dependency
  # drake::file_out() marks the .HTML as an output
  report = rmarkdown::render(
    knitr_in("egg-report.Rmd"),
    output_file = file_out("docs/egg-report.html"),
    quiet = TRUE
  )

)
```

You can put the functions in any order; {drake} takes care of the dependencies and works out which order in which to run them.

## Making it happen

So now we've got everything we need: our packages, functions and the plan. How do we execute the plan? We can use a [a small file called `make.R`](https://github.com/matt-dray/drake-egg-rap/blob/master/make.R) that brings everything together. 

### 1. Source the files

First, it uses the `source()` function on each .R script.

```{r eval=FALSE}
source(packages.R)  # load packages
source(functions.R)  # load bespoke functions
source(plan.R)  # load the plan
```

Running the plan file creates a data frame object[^df] It has columns called 'target' and 'command' and a row for each function in our analysis:

```{r eval=FALSE}
plan
```
```{r eval=FALSE}
# A tibble: 4 x 2
  target   command                                                                           
  <chr>    <expr>                                                                            
1 raw_data read_ods(path = "data/eggs-packers-02may19a.ods", sheet = "Packers_Annual",      …
2 data     clean_data(raw_data)                                                             …
3 plot     create_plot(data)                                                                …
4 report   render(knitr_in("egg-report.Rmd"), output_file = file_out("docs/egg-report.html")…
```

The plan object acts like an instruction booklet, which can be read 'to each target, apply the named command'. My simple example has only four instructions:

1. Read the raw data (the target) with `readODS::read_ods()` (the command)
1. Clean the data (target) with our `clean_data()` function (command)
1. Plot the data (target) with our `plot_data()` function (command)
1. Create an R Markdown report (target) with `rmarkdown::render()` (command)

Before we execute this plan, we can take a look at what a dependency graph of these targets looks like.

### 2. Visualise (optional)

Having created the `plan` object in the last step, we must now create a 'config' object: a list that contains lots of information about your plan. One element is an [igraph](https://igraph.org/) object that helps construct graphs from your workflow.

```{r eval=FALSE}
egg_config <- drake_config(plan)
```

A number of {drake} functions can take the config object and do something with the information inside it. In our case, we're going to pass the config to `vis_drake_graph()`, which builds an interactive dependency graph based on {visNetwork}.

```{r eval=FALSE}
vis_drake_graph(egg_config)
```

[The interactive output](https://matt-dray.github.io/drake-egg-rap/dependency-graph.html) is handy for seeing dependencies at a glance. It's shape-coded to show the target type (object, function, file) and colour-coded to show whether everything is up-to-date. At the moment it tells us that nothing is outdated; since we haven't actually run the plan yet.

### 3. Execute the plan

Running the plan is as simple as using  `make(plan)`.

This runs all the instructions laid out in the `plan` object. In our case, this outputs an HTML report, since the last step of the plan was to render an R Markdown file.

Of course, re-running the plan straight away again does... nothing. No code needs to be re-executed if nothing's changed! Remember that {drake} will identify changes for you and re-execute only the dependent parts.

### 4. Making a change

So if anything at all changes in our data or code then the downstream targets will be out of sync. Let's pretend we've changed a line of code in the `create_plot()` function, perhaps to alter its title. What do you think will happen?

Well, {drake} knows there's been a change! Running `outdated(egg_config)` prints the file that's been altered, plus all the impacted files that depend on it.

If we [take another look at the visualisation now](https://matt-dray.github.io/drake-egg-rap/dependency-graph-outdated.html), we can see that certain targets have been recoloured to show that they're out of date.

Re-running the plan will now cause these targets to be regenerated. Targets that aren't impacted by the change won't be re-run.

Where are the targets stored that didn't need to be recreated? Turns out that {drake} creates a `.drake/` folder to caches these objects and grabs then when needed. 

Items can be pulled from this cache by the user with the the `loadd()` and `readd()` functions. For example, the R Markdown report in my example simply calls the rendered plot object from the cache using `readd()`. This can help keep the R Markdown file less cluttered and more readable.

# In review

This post has shown how {drake}:

* remembers the dependencies between the files of your analysis
* only re-run what needs to be re-run

Of course, [{drake} does a lot more than this](https://ropenscilabs.github.io/drake-manual/), but even this is enough help public servants to manage statistical reports that are more reliable and trustworthy.


[^egg]: This publication could be a good candidate for RAP: content remains fairly similar between quarterly releases and it's required to meet high standards of quality because it's badged as [National Statistics](https://www.statisticsauthority.gov.uk/osr/list-of-national-statistics/).
[^scripts]: You don't have to restrict yourself to this configuration of scripts, but it can make it easier to handle your project.
[^df]: It actually has multiple classes: `drake_plan`, `tbl_df`, `tbl` and `data.frame`.