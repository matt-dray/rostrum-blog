---
title: 'Can {drake} RAP?'
author: Matt Dray
date: '2019-06-10'
slug: drake-lays-an-egg
categories:
  - R
tags:
  - reproducibility
  - drake
  - eggs
  - rap
  - reproducible analytical pipelines
  - make
  - make file
draft: yes
---

# tl;dr

# RAP

[Reproducible Analytical Pipelines](https://ukgovdatascience.github.io/rap-website/) (RAP) is an approach to generating [UK government's statistical reports](https://www.gov.uk/search/research-and-statistics) that improves reproducibility, minimises errors and speeds up production.

RAP does away with the tangled webs of spreadsheets, copy-pasting errors and infernal `publication_FINAL-v2_md-comments_FINAL.docx` file naming. Instead, RAP encourages a script-based workflow that's beefed up with stuff like version control, dependency management and automated testing.

# Make

Projects can become complicated as multiple inputs, script files and outputs build up.

You need to re-run code if any changes are made. Can you remember exactly which bits of code need to be re-run? Or will you have to re-run everything from scratch? The latter is especially tedious in a large project.

A ['makefile'](https://en.wikipedia.org/wiki/Makefile) can help you. In short, it's a text file in which you write each step of your analysis in a recipe-like format. Dependencies between data, code and outputs are recorded.

Now when something changes, only the impacted steps will be re-executed. This saves compute time and means you don't have to remember any dependencies yourself.

# {drake} it to make it

[{drake}](https://github.com/ropensci/drake) is a package by [Will Landau](https://wlandau.github.io/) that lets you have all the benefits of makefiles with R syntax.

With {drake} you prepare a 'plan' script written in R that records all the functions to be executed. You then 'make' the plan to run all the steps of the analysis.

There's some helpful material out there for learning more about {drake}:

* [user manual](https://ropenscilabs.github.io/drake-manual/)
* [documentation](https://ropensci.github.io/drake/)
* [cheat sheet](https://github.com/krlmlr/drake-sib-zurich/blob/master/cheat-sheet.pdf) by Kirill MÃ¼ller
* ['drake for workflow happiness'](https://aedobbyn.github.io/nyc-fires/index.html#1) slides by [Amanda Dobbyn](https://dobb.ae/)

# Eggsample

I've made a very simple {drake} demo for an imaginary RAP project, which recreates a small part of a [statistical publication that tracks UK egg production](https://www.gov.uk/government/statistics/egg-statistics)[^egg].

The code is on [GitHub](https://github.com/matt-dray/drake-egg-rap), along with an [HTML version of the demo report](https://matt-dray.github.io/drake-egg-rap/egg-report.html).

## A cunning plan

The repo contains [a folder](https://github.com/matt-dray/drake-egg-rap/tree/master/R) with three simple but important scripts[^scripts]:

1. [`packages.R`](https://github.com/matt-dray/drake-egg-rap/blob/master/R/packages.R) loads the packages we need for analysis using calls to `library()`
1. [`functions.R`](https://github.com/matt-dray/drake-egg-rap/blob/master/R/functions.R) contains bespoke functions
1. [`plan.R`](https://github.com/matt-dray/drake-egg-rap/blob/master/R/plan.R) is the recipe document that brings everything together

The first two don't need much more explaining. The `plan.R` file is a little different but is straightforward. It contains a call to `drake::drake_plan()`, to which you pass the functions that make up your analysis:

```{r eval=FALSE}
plan <- drake_plan(
  
  raw_data = read_ods(
    path = "data/eggs-packers-02may19a.ods",
    sheet = "Packers_Annual",
    skip = 8
  ),
  
  data = clean_data(raw_data),
  
  plot = create_plot(data),
  
  report = rmarkdown::render(
    knitr_in("egg-report.Rmd"),
    output_file = file_out("docs/egg-report.html"),
    quiet = TRUE
  )

)
```


## Straight from the source

There is [a simple file called `make.R` in the root](https://github.com/matt-dray/drake-egg-rap/blob/master/make.R) that reads each of the .R script files using the `source()` function. The first two scripts simply load the packages and functions we need, while `source(plan.R)` generates a data frame[^df] called 'plan'.

The plan data frame has 'target' and 'command' columns and multiple rows. It acts like instruction booklet that can be read 'for each function we specified in the `plan.R` file, apply the named command to the named target'.

So [in my simple example plan](https://github.com/matt-dray/drake-egg-rap/blob/master/R/plan.R) there are four instructions:

1. Read the raw data (target) with `readODS::read_ods()` (command)
1. Clean the data (target) with our `clean_data()` function (command)
1. Plot the data (target) with our `plot_data()` function (command)
1. Create an R Markdown report (target) with `rmarkdown::render()` (command)

The plan is executed with `make(plan)`. This runs all the instructions and outputs an HTML report, since the last step of the plan was to render an R Markdown file.

Great, our {drake} pipeline is successful.

## Visualise

{drake} provides some visual methods for inspecting the dependencies between targets. For example, it uses {visNetwork} to create an interactive graph.

{drake} provides some possibilities for visualising the dependencies between targets and highlights which are up to date.

First you generate 'config' file: a list object that contains lots of configuration information for your plan. One element is an igraph object that helps construct graphs from your workflow.

```{r eval=FALSE}
egg_config <- drake_config(plan)
```

A number of {drake} functions can take the config object and do something with the information inside it. In our case, we're going to pass the config to `vis_drake_graph()`, which builds an interactive dependency graph based on {visNetwork}.

```{r eval=FALSE}
vis_drake_graph(egg_config)
```

[The interactive output](https://matt-dray.github.io/drake-egg-rap/dependency-graph.html) is handy for seeing dependencies at a glance. It's shape-coded to show the target type (object, function, file) and colour-coded to show whether everything is up-to-date.

## Making a change

Of course, re-running the plan again does... nothing. No code needs to be re-executed if nothing's changed! Remember that {drake} will identify changes for you and re-execute only the dependent parts. 

However, if a single data point or line of code changes, then the the downstream targets -- the plot and the report -- will be out of sync. You can check this with `outdated(egg_config)`.

If we [take another look at the visualisation now](https://matt-dray.github.io/drake-egg-rap/dependency-graph-outdated.html), we can see that certain targets have been recoloured to show that they're out of date.

Re-running the plan will cause these targets to be regenerated. Targets that aren't impacted by the change won't be re-run.

Where are the targets stored that didn't need to be recreated? Turns out that {drake} creates a `.drake/` folder to caches these objects and grabs then when needed. 

Items can be pulled from this cache by the user with the the `loadd()` and `readd()` functions. For example, the R Markdown report in my example simply calls the rendered plot object from the cache using `readd()`. This can help keep the R Markdown file less cluttered and more readable.

# Going further

* complicated projects
* high performance computing

[^egg]: This publication could be a good candidate for RAP: content remains fairly similar between quarterly releases and it's required to meet high standards of quality because it's badged as [National Statistics](https://www.statisticsauthority.gov.uk/osr/list-of-national-statistics/).
[^scripts]: You don't have to restrict yourself to this configuration of scripts, but it can make it easier to handle your project.
[^df]: It actually has multiple classes: `drake_plan`, `tbl_df`, `tbl` and `data.frame`.