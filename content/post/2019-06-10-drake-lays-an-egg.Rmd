---
title: 'Can {drake} RAP?'
author: Matt Dray
date: '2019-06-10'
slug: drake-lays-an-egg
categories:
  - R
tags:
  - reproducibility
  - drake
  - eggs
  - rap
  - reproducible analytical pipelines
  - make
  - make file
draft: yes
---

# RAP

[Reproducible Analytical Pipelines](https://ukgovdatascience.github.io/rap-website/) (RAP) is an approach to generating [UK government's statistical reports](https://www.gov.uk/search/research-and-statistics) that improves reproducibility, minimises errors and speeds up production.

RAP does away with the tangled webs of spreadsheets, copy-pasting errors and infernal `publication_FINAL-v2_md-comments_FINAL.docx` file naming. Instead, RAP encourages a script-based workflow that's beefed up with stuff like version control, dependency management and automated testing.

# Make

Projects can become complicated as multiple inputs, script files and outputs build up.

You need to re-run code if any changes are made. Can you remember exactly which bits of code need to be re-run? Or will you have to re-run everything from scratch? The latter is especially tedious in a large project.

A ['makefile'](https://en.wikipedia.org/wiki/Makefile) can help you. In short, it's a text file in which you write each step of your analysis in a recipe-like format. Dependencies between data, code and outputs are recorded.

Now when something changes, only the impacted steps will be re-executed. This saves compute time and means you don't have to remember any dependencies yourself.

# {drake} it to make it

[{drake}](https://github.com/ropensci/drake) is a package by [Will Landau](https://wlandau.github.io/) that lets you create makefiles using R syntax.

With {drake} you prepare a 'plan' script written in R that records all the functions to be executed. You then 'make' the plan to run all the steps of the analysis.

There's some helpful material out there for learning more about {drake}:

* [user manual](https://ropenscilabs.github.io/drake-manual/)
* [documentation](https://ropensci.github.io/drake/)
* [cheat sheet](https://github.com/krlmlr/drake-sib-zurich/blob/master/cheat-sheet.pdf) by Kirill MÃ¼ller
* ['drake for workflow happiness'](https://aedobbyn.github.io/nyc-fires/index.html#1) slides by [Amanda Dobbyn](https://dobb.ae/)

# Eggsample

I've made a very simple {drake} demo for an imaginary RAP project, which recreates a small part of a [statistical publication that tracks UK egg production](https://www.gov.uk/government/statistics/egg-statistics)[^egg].

The code is on [GitHub](https://github.com/matt-dray/drake-egg-rap), along with an [HTML version of the demo report](https://matt-dray.github.io/drake-egg-rap/egg-report.html).

## A cunning plan

The repo contains [a folder](https://github.com/matt-dray/drake-egg-rap/tree/master/R) with three simple but important scripts[^scripts]:

1. [`packages.R`](https://github.com/matt-dray/drake-egg-rap/blob/master/R/packages.R) loads the packages we need for analysis using calls to `library()`
1. [`functions.R`](https://github.com/matt-dray/drake-egg-rap/blob/master/R/functions.R) contains bespoke functions
1. [`plan.R`](https://github.com/matt-dray/drake-egg-rap/blob/master/R/plan.R) is the recipe document that brings everything together

The first two don't need much more explaining. The `plan.R` file is a little different but is straightforward. It contains a call to `drake::drake_plan()`, to which you pass the functions that make up your analysis:

```{r eval=FALSE}
plan <- drake_plan(
  
  raw_data = read_ods(
    path = "data/eggs-packers-02may19a.ods",
    sheet = "Packers_Annual",
    skip = 8
  ),
  
  data = clean_data(raw_data),
  
  plot = create_plot(data),
  
  report = rmarkdown::render(
    knitr_in("egg-report.Rmd"),
    output_file = file_out("docs/egg-report.html"),
    quiet = TRUE
  )

)
```

## Straight from the source

There is [a simple file called `make.R` in the root](https://github.com/matt-dray/drake-egg-rap/blob/master/make.R) that reads each of .R script files using the `source()` function. The first two scripts simply load the packages and functions we need, while `source(plan.R)` generates a data frame[^df] called 'plan'.

This data frame has 'target' and 'command' columns and multiple rows. It's like an instruction booklet that can be read 'for each function we specified in the `plan.R` file, apply the named command to the named target'.

So [in my example](https://github.com/matt-dray/drake-egg-rap/blob/master/R/plan.R) there are four instructions:

1. Read the raw data (target) with `readODS::read_ods()` (command)
1. Clean the data (target) with our `clean_data()` function (command)
1. Plot the data (target) with our `plot_data()` function (command)
1. Create an R Markdown report (target) with `rmarkdown::render()` (command)

## Enact the plan

Now you can run the `make()` function on the 'plan' object, which will run the list of instructions in the plan.

The report will pop into existence and any created objects will be stored in a cache in a folder called '.drake', which is hidden from the user.

Of course, re-running the plan again does... nothing. No code needs to be re-executed if nothing's changed! {drake} will identify changes for you and re-execute only the dependent parts. 

If, for example, a single data point changes, then the the plot and the report will be recreated, since they're downstream of the data. Targets that aren't impacted by the change won't be re-run, since {drake} can just refer to the cache.

Incidentally, you can pull objects from the cache using the `loadd()` and `readd()` functions. For example, the R Markdown report in my example simply calls the plot object from the cache using `readd()`. This can help keep the R Markdown file less cluttered and more readable.

## Visualise

To help with this, {drake} provides a nice interactive visualisation of the dependencies and highlights which targets have changed (if any), and therefore which downstream dependencies will be impacted as a result.

First you generate 'config' file: a list object that contains lots of configuration information for your plan. 

```{r eval=FALSE}
egg_config <- drake_config(plan)
```

For example, `egg_config$cache_path` contains the filepath for where the cache is.

A number of {drake} functions can take the config object and do something with the information inside it. In our case, we're going to pass the config to `vis_drake_graph()`, which builds an interactive dependency graph.

```{r eval=FALSE}
vis_drake_graph(egg_config)
```

[INSERT GRAPH]

This is handy for seeing dependencies at a glance. It's shape-coded to show the target type (object, function, file) and colour-coded to show whether everything is up-to-date.

So if we change something in our analysis and re-view the graph without updating anything, we'll see that the colour of the dependent steps has changed.

[INSERT GRAPH]

# Going further

* complicated projects
* high performance computing

[^egg]: This publication could be a good candidate for RAP: content remains fairly similar between quarterly releases and it's required to meet high standards of quality because it's badged as [National Statistics](https://www.statisticsauthority.gov.uk/osr/list-of-national-statistics/).
[^scripts]: You don't have to restrict yourself to this configuration of scripts, but it can make it easier to handle your project.
[^df]: It actually has multiple classes: `drake_plan`, `tbl_df`, `tbl` and `data.frame`.