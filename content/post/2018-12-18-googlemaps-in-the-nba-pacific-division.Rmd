---
title: The NBA Northwest Division with gmapsdistance
author: Matt Dray
date: '2018-12-18'
slug: nba-travel
categories:
  - R
tags:
  - NBA
  - gmapsdistance
  - dplyr
  - rvest
  - stringr
draft: yes
---

Matt Dray ([@mattdray](https://www.twitter.com/mattdray))

# The NBA

The USA is quite big.

The National Basketball Association (NBA) recognised this and organised their teams geographically: two 'conferences' -- Western and Eastern -- with three divisions of five teams each. 

You'd think that paying _within_ the division would cut journey time between games, but that's not always the truth.

For example, the Central division is (relatively) tightly packed. It contains the Chicago Bulls, Cleveland Cavaliers, Detroit Pistons, Indiana Pacers and Milwaukee Bucks -- cities clustered by the Great Lakes.

Converesely, the Northwest Division of the Western Conference stretches from the Portland Trail Blazers in the Pacific Northwest to Oklahoma City Thunder, with Utah Jazz and Colorado's Denver Nuggets between them. Oh, and Minnesota Timberwolves are also part of the division despite being far closer to the Central division's teams.

What does this mean for the travelling support?


# Travel time with `gmapsdistance`

The R package [`gmapsdistance`](https://github.com/rodazuero/gmapsdistance) wraps the [Google Maps](https://www.google.co.uk/maps) [API](https://medium.freecodecamp.org/what-is-an-api-in-english-please-b880a3214a82). You can use it to query origin and destination points for travel distance (metres) and duration (seconds) for several modes of travel: on foot, by car, by public transport, or by bicycle (for parts of North America only).

Before we make use of the Google Maps API we need to obtain a key. The process is outlined in detail on [the Google developer pages](https://developers.google.com/maps/documentation/distance-matrix/get-api-key#key). [Go to the website](https://cloud.google.com/maps-platform/) and follow the instructions.

Why do you need a key? Because Google want to prevent misuse of their service and so they can keep track of your access; you get a certain amount (currently $200) free per month.

You can set the API key with `set.api.key("YOURKEY")` so that the `key = get.api.key()` argument in the `gmapsdistance()` package can fetch it when called.

# Get data

We can use [Hadley Wickham's `rvest` package](https://github.com/hadley/rvest) to scrape the [Wikipedia page for the National Basketball Association (NBA)](https://en.wikipedia.org/wiki/National_Basketball_Association), which contains a table of teams and locations. 

We'll start by setting up our workspace with some packages.

```{r load-packages, message=FALSE, warning=FALSE}
library(dplyr)  # data manipulation
library(rvest)  # web scraping
library(stringr)  # string manipulation
```

Then we'll create objects that define the HTML for the web page and the table we want. The latter is defined using a CSS selector or, as in our case, an xpath. You can use the 'inspect' function in your browser or [the selectorgadget browser extension](https://selectorgadget.com/) to get this information. 

```{r set-scrape-variables}
# Read the HTML from a specified web URL
html <- read_html("https://en.wikipedia.org/wiki/National_Basketball_Association")

# Use the Scrapy tool or 'inspect' in your browser to get the table xpath
table_xpath <- '//*[@id="mw-content-text"]/div/table[4]'
```

Now we can collect the table and manipulate it.

We could use the latitude and longitude from this table as our origin and destination points, but the arena name, city and state will be enough. We can create a column in our data in the form `arena+city+state`, which is the format required by Google Maps.

```{r get-nba-table}
nba_table <-
  html_nodes(x = html, xpath = table_xpath) %>%  # scrape the HTML
  html_table(fill = TRUE, header = NA) %>%  # parse as table
  as.data.frame() %>%  # convert from list
  filter(Division == "Northwest") %>%  # NW division only
  mutate(
    Search = paste(Arena, City.State),  # combine location details
    Search = str_replace_all(Search, ",", ""),  # replace comma with blank
    Search = str_replace_all(Search, " ", "+")  # replace space with plus
  ) %>% 
  select(Team, Arena, State = City.State, Search)  # columns of interest
```

So now we have a simple table of teams, locations and a search string that we'll pass to `gmapsdistance()`.

# Calculate distances

The basic arguments to the  `gmpasdistance()` function are the origin and destination (can be an address, postcode or latlong coordinates), the mode of travel (car, public transit, walking) and the return format (shape) of the data (each origin-destination pair per row, or a matrix). We want all possible combinations

```{r use-gmapsdistance, cache=TRUE}
library(gmapsdistance)

nw_nba_travel <- 
  gmapsdistance(
    key = get.api.key(),  # call API key
    origin = nba_table$Search,  # start point of journey
    destination = nba_table$Search,  # end point of journey
    mode = "driving",  # driving time
    combinations = "all",
    shape = "long"  # format of output data (origin and destination as cols)
  )
```

The output is a list with three elements:

1. Time in seconds (`$Time`)
2. Distance in metres (`$Distance`)
3. Status of the call (`$Status`) -- was it successful?

Each list element has three columns:

* `or` -- the origin point
* `de` -- the destination point
* one of `Time`, `Distance` and `Status`

Let's start with `Status`. Were all the requests actioned?

```{r status}
sch_distances$Status  # isolate status element of returned list
```

We want the status `OK`, which indicates that there were no problems and the distances were collected with no errors. The `PLACE_NOT_FOUND` error is returned in the `Status` column when Google Maps can't locate your origin or destination.

So what were the distances between the locations in metres?

```{r distance}
sch_distances$Distance  # isolate distance (metres) element of returned list
```

And how much time does this translate to, in seconds, when driving between the locations?

```{r time}
sch_distances$Time  # isolate time (seconds) element of returned list
```

That's great, but still not super-friendly to use, especially over long distances.

# Manipulate the data

Let's create a more meaningful table for our purposes. Let's say we only care about the distances for now, so we'll focus on that element of the list and join in information about the origin from the Get Information About Schools data

```{r list-to-df, warning=FALSE}
distance_info <- sch_distances$Distance %>%  # to the distance data...
  dplyr::left_join(
    y = select(
      gias, 
      establishmentname, postcode  # join these columns from the GIAS data
      ),   
    by = c("or" = "postcode")  # match on postcode values (origin)
  ) %>% 
  dplyr::left_join(   # now join...
    y = select(
      gias,  # from GIAS...
      establishmentname, postcode  # these columns
      ),
    by = c("de" = "postcode"),  # match on postcode values (destination)
    suffix = c("_or", "_de")  # add col name suffixes for origin/destination
  )

dplyr::glimpse(distance_info)  # inspect data
```

While we're at it, we can look arbitrarily at the longest distances.

```{r arrange}
distance_info %>%
  dplyr::mutate(  # create new columns
    Kilometres = round(Distance/1000, 1),  # calculate km from m
    Miles = round(Kilometres * 0.621371, 1)  # convert to miles
  ) %>% 
  dplyr::select(  # select columns to rename and retain
    Origin = establishmentname_or,
    Destination = establishmentname_de,
    `Kilometres`,
    `Miles`
    ) %>% 
  dplyr::arrange(desc(Kilometres)) # arrange by longest distance first
```
