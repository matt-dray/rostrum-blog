---
title: Art of the Possible
author: Matt Dray
date: '2018-10-04'
slug: art-of-the-possible
categories: []
tags: []
draft: true
---



<p>Matt Dray</p>
<div id="colour-search" class="section level1">
<h1>Colour search</h1>
<p>Searching images by colour is all the rage:</p>
<ul>
<li><a href="https://artsexperiments.withgoogle.com/artpalette/colors/a46053-433932-c2ad8f-b5996a-746251">Google Arts &amp; Culture</a></li>
<li><a href="https://www.designspiration.net/search/saves/?q=%2389ebd7%20%23afff11%20%23e5ff91%20%23ff9775%20%23f38d00">Designspiration</a></li>
<li><a href="https://labs.tineye.com/multicolr/">TinEye Multicolr</a></li>
<li><a href="https://www.google.co.uk/advanced_image_search">Google Advanced Image Search</a></li>
</ul>
<p>To do this you need to know how much of each colour is in the image.</p>
<p>So let’s look at a kind-of-crappy half-baked method in R for achieving this.</p>
</div>
<div id="a-very-simple-implementation" class="section level1">
<h1>A very simple implementation</h1>
<p>The steps go like this:</p>
<ol style="list-style-type: decimal">
<li>Read in an image</li>
<li>Convert RGB (Red-Green-Blue) values to simple-named colours</li>
<li>Get percentage of image filled by each colour</li>
<li>???</li>
<li>Profit</li>
</ol>
</div>
<div id="read-image" class="section level1">
<h1>Read image</h1>
<p>There’s a number of ways to read images into R. We’ll use the <code>readImage()</code> function from the <code>OpenImageR</code> package.</p>
<p>Remember to use <code>install.packages()</code> if you haven’t installed any of the packages in this post. I’m also assuming that you have a test image, named <code>test_image.jpg</code>, in a folder called <code>img</code> in your working directory.</p>
<pre class="r"><code>library(OpenImageR)  # load package
image_in &lt;- readImage(&quot;img/test_image.jpg&quot;)  # read image</code></pre>
<p>The image has been read into R as an <em>array</em>, an object type that can hold data in multiple dimensions.</p>
<p>Our image has three dimensions: a two-dimensional matrix representing the ‘pixels’ of the image plus <a href="https://en.wikipedia.org/wiki/Channel_(digital_image)">a third dimension for each ‘colour channel’ of red, green and blue (RGB)</a>.</p>
<p>You can see this when you check the <code>str</code>ucture of the image:</p>
<pre class="r"><code>str(image_in)  # check structure</code></pre>
<p>So it’s <code>[matrix rows, matrix columns, colour channels]</code>. There’ll be three colour channels, of course: RGB. The number of rows and columns will depend on how big the image is.</p>
<p>So we could get the values of each colour channel for the top-left nine pixels of the image (a three-by-thre matrix).</p>
<pre class="r"><code># first three elements of first two dimensions
# and all the elements of the third dimension
image_in[1:3, 1:3, ]</code></pre>
<p>For example, a point will be yellow if it has maximum values for red and blue channels and the minimum value in the green channel. <a href="http://web.stanford.edu/class/cs101/image-rgb-explorer.html">There are online tools for exploring RGB permutations</a>.</p>
<p>To prove we can rebuild the image from the array, we can use the <code>imageShow()</code> function from <code>OpenImageR</code>.</p>
<pre class="r"><code>imageShow(image_in)</code></pre>
</div>
<div id="assign-simple-colours" class="section level1">
<h1>Assign simple colours</h1>
<p>You could do k-means clustering to bucket the full colour set into <em>k</em> groups, each with a representative RGB value. This is a good approach for simplifying images; you could go from 256 colours to 8, for example. <a href="">You can find methods for this online</a>.</p>
<p>But actually we want to describe the image with <em>simple</em> colours, not the average of a cluster. So we could first convert the RGB values in our array to a set of basic colours with recognisable names like ‘yellow’ and ‘black’. Then we just tally them.</p>
<pre class="r"><code>image_melt &lt;- image_in %&gt;% melt()  # why not use gather? becasue we&#39;re working with a matrix

image_spread &lt;- image_melt %&gt;% 
  spread(
    key = Var3,
    value = value
  ) %&gt;% 
  transmute(
    red = round(`1` * 255),
    green = round(`2` * 255),
    blue = round(`3` * 255)
  ) %&gt;%
  rownames_to_column() %&gt;% 
  as_tibble()</code></pre>
</div>
