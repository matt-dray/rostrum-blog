---
title: 'Advanced R: anchovy pizza'
author: 'Matt Dray'
date: '2021-01-23'
slug: adv-r-names
categories:
  - code
tags:
  - advanced-r
  - book
  - learning
  - pizza
  - r
draft: yes
---

<div class="figure">
<img src="/post/2021-01-23-adv-r-foundations_files/pizza.gif" alt="Bird's-eye view of five large margherita pizzas on a table before and after consumption" width="75%"/>
</div>

# tl;dr

I bought [Hadley Wickham](http://hadley.nz/)'s [Advanced R](https://adv-r.hadley.nz/) book[^buy] to help me better understand R's quirks. Can names and values (chapter 2) be explained with a contrived pizzeria analogy?[^royale]

# A pizza by any other name

Welcome to the pizzeria. Our specialty is _pizza alla napoletana_ topped with mozzarella, tomatoes and anchovies.

```{r}
# Create a character-vector object
napoletana <- c("ðŸ§€", "ðŸ…", "ðŸŸ")
```

The English version of the menu calls it 'Neapolitan' pizza.

```{r}
# Copy the character-vector object
neapolitan <- napoletana
all(neapolitan == napoletana)  # they're equal
```

We store our unique pizza topping sets in a recipe book. If you look up 'napoletana' and 'Neapolitan' in the index of the book, you'll see they point to the same recipe. 

```{r}
# The {lobstr} package helps understand object structure
library(lobstr)  # after install.packages("lobstr")

# Get the specific object 'address' in your computer's memory
# Both names point to the same object
obj_addr(napoletana)
obj_addr(neapolitan)
```

The pizzaiolos don't care: different names, same pizza. Their 'recipe codes' are the same.

<div class="tip">
`r emo::ji("book")`  "The object, or value, doesn't have a name; it's actually _the name that has a value_" (page 19)
</div>

# Copying a recipe, modifying it

We recently added _pizza pugliese_ to the menu. The napoletana was copied and then modified to produce the pugliese, which has onions instead of anchovies.

```{r}
pugliese <- napoletana       # copy the object
all(pugliese == napoletana)  # the objects are the same
pugliese[[3]] <- "ðŸ§…"   # modify the third element
pugliese == napoletana  # they're no longer the same
```

When we look up these names in the index of our recipe book, we see that they point to different places.

```{r}
# Now the names point to different objects
# We modified the copy, so it becomes a new object in memory
obj_addr(napoletana)
obj_addr(pugliese)
```

<div class="tip">
`r emo::ji("book")` "This behaviour is called _copy-on-modify_" (page 22)
</div>

Here's how our menu looks.

```{r}
apulian <- pugliese  # copy pugliese object, English name

# A comparison of the pizza object structures
knitr::kable(
  tibble::tribble(
    ~Language, ~Name, ~`Toppings`, ~`Recipe code`, 
    "ITA", "Pizza alla napoletana", napoletana, obj_addr(napoletana),
    "ENG", "Neapolitan pizza", neapolitan, obj_addr(neapolitan),
    "ITA", "Pizza pugliese", pugliese, obj_addr(pugliese),
    "ENG", "Apulian pizza", apulian, obj_addr(apulian)
  )
)
```

Pizza alla napoletana and its copy, Neapolitan pizza, point to the same recipe code. 

Pizza pugliese was a copy of pizza alla napoletana, but it now points to a different recipe code. Why? An element was changed, anchovies to onions, so a new recipe code was required.

Apulian pizza is a copy of the pizza pugliese recipe, so they point to the same unique topping set.

# Efficient recipe management with lists

Our knowledge management system was, however, a bit inefficient: the mozzarella and tomato toppings existed twice in our recipe book, once for each pizza.

So we updated our recipe system to store each topping separately with their own special reference codes too.

Again, we wrote down the pizza napoletana toppings, copied them, then switched the anchovies for onions. Like in our old system, the two pizzas differ in their third element.

```{r}
napoletana <- list("ðŸ§€", "ðŸ…", "ðŸŸ")  # toppings as list elements
pugliese <- napoletana  # make a copy
identical(pugliese, napoletana) # they're the same
pugliese[[3]] <- "ðŸ§…"   # make a change
identical(pugliese, napoletana) # now they're different
```

In the new system, each topping also has its own unique ingredient code. This means both pizza recipes point to the same ingredient codes for tomato and mozzarella.

```{r}
# Compare addresses in memory for the lists
# Each 'block' below is a list object (pizza)
# Each element is a character vector (topping)
ref(napoletana, pugliese)
```

So our pizza names point to pizza recipes that themselves point out to toppings.

<div class="tip"> 
`r emo::ji("book")`
"This list is more complex [than a vector] because instead of storing the values itself, it stores _references to them_" (page 25)
</div>

This means we can be more efficient in storing our pizza recipes, particularly if we expand our menu to more than two pizzas.[^damichele]

# Customer orders in data frames

How do we manage orders? Wait staff write down each order in a column, with a row for each topping.

Let's say a couple orders a pizza napoletana and a pizza pugliese.

```{r}
# Create a data.frame, which is a list of vectors
order <- data.frame(
  napoletana = c("ðŸ§€", "ðŸ…", "ðŸŸ"),
  pugliese = c("ðŸ§€", "ðŸ…", "ðŸ§…")
)

knitr::kable(order)
```

<div class="tip"> 
`r emo::ji("book")` "Data frames are lists of vectors" (page 26) 
</div>

But wait: the customer who ordered the napoletana is hungry for more anchovies!

```{r}
order_update <- order  # copy the data.frame object
order_update[3, 1] <- "ðŸŸðŸŸ"  # modify the new object
knitr::kable(order_update)
```

We use a code reference system for our orders too and it works just like our old recipe system.

The napoletana was modified after it was copied, so the recipe code for that pizza was updated. The pugliese didn't change, so its code was maintained.

Since one of the pizza orders was changed, our reference code for the entire order was changed too.

```{r}
# Compare the data.frame structures
# Modified column gets new code, object gets new code
# Second column unchanged, code stays the same
ref(order, order_update)
```

<div class="tip">
`r emo::ji("book")`
"If you modify a column, only that column needs to be modified" (page 26)
</div>

The buffala mozzarella is especially bountiful this year; the waiter suggests both patrons add some more.

The order is copied once more and the waiter modifies the 'cheese row' for both pizzas.

```{r}
order_final <- order_update  # copy the object
order_final[1, 1:2] <- "ðŸ§€ðŸ§€"  # modify row one of both columns
knitr::kable(order_final)
```

Altering the cheese row means both pizza columns are copied and given new codes. Of course, the order gets a whole new code of its own because the toppings were changed.

```{r}
# Compare data.frame structures again
# All columns modified, so copies made
# data.frame and column memory locations all differ
ref(order, order_final)
```

<div class="tip"> 
`r emo::ji("book")` "If you modify a row, every column is modified, which means every column must be copied" (page 27) 
</div>

_Buon appetito_.

# Il conto

So the analogy is too contrived.

---
<details><summary>Session info</summary>
```{r sessioninfo, echo=FALSE}
sessioninfo::session_info()
```
</details>

[^buy]: You can [buy the book](https://www.amazon.com/gp/product/0815384572/ref=as_li_tl?ie=UTF8&tag=hadlwick-20&camp=1789&creative=9325&linkCode=as2&creativeASIN=0815384572&linkId=9f8b9df5da858c12a5e9905aea66bf08), or [view it for free online](https://adv-r.hadley.nz/).
[^royale]: Initially I went with a metaphor about how a Quarter Pounder with Cheese is called a Royale with Cheese in Paris (or indeed, a Krusty Burger with Cheese is called a Quarter Pounder with Cheese at McDonald's), but the pop culture reference was better than the actual utility of the metaphor.
[^damichele]: Of course, if you're really serious about pizza, you only offer marianara and margherita [as per L'antica Pizzeria Da Michele](http://www.damichele.net/le-nostre-pizze/), which is where I took the photos that are in this post.