---
title: "lubridate"
author: Matt Dray
date: '2021-10-05'
slug: lubridate-fns
categories:
  - code
  - tutorial
tags:
  - r
draft: yes
---

```{r}
set.seed(1)

```


Use whatever dependencies you want, I really don't care. I write joke packages that I don't put on CRAN, so.

I see the benefit of minimising dependencies. I understand the drawback of reinventing the wheel. 

I appreciate packages that handle things I can't be bothered with, like datetimes. What's 29 February plus one year? I don't care and I don't want to solve it.

Anyway, 'lubrigate' happened last week. I'm not going into detail here, but a test failure in the popular tidyverse package {lubridate} would've seen its expulsion from CRAN along with hundreds of packages that depend on it.

Made me wonder:

1. How many packages list {lubridate} as an import?
1. How many {lubridate} functions are used in each package?
1. If using few lubridate functions, are they functions that handle annoying dateimte problems?

I'd actually like to do this for all CRAN packages and their dependencies, but I don't have a personal CRAN mirror and I don't write performant code.

# CRAN packages

`CRAN_package_db()` is a convenient base R function that returns information about packages hosted on CRAN. We can filter if for the packages that import {lubridate}. In other words, any packages that list {lubridate} in the `Imports` section of the package DESCRIPTION file.

```{r cran-db}
cran <- tools::CRAN_package_db()

library(dplyr, warn.conflicts = FALSE)
library(tidyr)
library(stringr)

imports_lubridate <- cran |> 
  filter(str_detect(Imports, "lubridate")) |> 
  pull(Package)

head(imports_lubridate)
```

Right, so that's `r length(imports_lubridate)` packages out of `r nrow(cran)` (`r 100 * round(length(imports_lubridate) / nrow(cran), 2)`%). Is that a lot? Well, the multi-purpose tidyverse package {dplyr} is listed in the Imports of `r cran |> filter(str_detect(Imports, "dplyr")) |> nrow()` other packages.

# Install

Spoiler: we have to install all these packages so we can analyse the frequency of use of the dependencies they contain. This is a mild pain.

```{r echo=FALSE}
tmp <- tempdir()

purrr::walk(
  imports_lubridate,
  ~install.packages(.x, destdir = tmp, dependencies = FALSE, Ncpus = 4)
)
```

I've tried to make this mildly less painful by preventing download of the dependencies of each package and by maximising the number of cores working on the downloads.

# {itdepends}

{itdepends} is available from GitHub.

```{r install-itdepends, eval=FALSE}
remotes::install_github("jimhester/itdepends")
```

Now we can pass each of these package names to the `dep_usage_package()` function of {itdepends}. We get back a dataframe for each package, listing each function call it makes and the package that the function comes from.

The approach I decided to take here was to create an empty list of known size (i.e. the length of the number of packages we installed) and then loop over each package name to write each list element with the output from `dep_usage_pkg()`.

The function sometimes fails, so I've put it in a `tryCatch()` and any errors are recorded as an empty dataframe. I was having some trouble getting the loop to continue to the next package after a failure, so I've added a mildly awkward use of `next` from base R's control flow functions, which [I took from StackOverflow](https://stackoverflow.com/a/55937737), naturally.

```{r echo=FALSE}
dep_list <- vector("list", length(imports_lubridate)) |> 
  setNames(imports_lubridate)

for (i in imports_lubridate) {
  
  cat(i, "\n")
  
  skip <- FALSE
  
  tryCatch(
    { dep_list[[i]] <- itdepends::dep_usage_pkg(i)
    dep_list[[i]]$focus <- i },
    error = function(e) { 
      dep_list[[i]] <- data.frame(
        pkg = NA_character_, fun = NA_character_, focus = NA_character_
      )
      skip <<- TRUE 
    }
  )
  
  if (skip) { next }
  
}
```

I absolutely do not claim this to be the best, most optimised approach. but it works. The first couple of elements look like this:

```{r}
count(dep_list[[1]], fun)
```

```{r}
# List to dataframe
dep_df <- do.call(rbind, dep_list)

# Frequency of named lubridate functions by package
pkg_fn_count <- dep_df |>
dplyr::filter(pkg == "lubridate") |>
dplyr::count(focus, fun)

# Frequency of all lubridate functions by package
fn_distinct_count <- dep_df |>
dplyr::filter(pkg == "lubridate") |>
dplyr::distinct(focus, fun) |>
dplyr::count(focus, sort = TRUE)

# Frequency of all lubridate functions by package
fn_nondistinct_count <- dep_df |>
dplyr::filter(pkg == "lubridate") |>
dplyr::count(focus, sort = TRUE)

# Histogram: distinct {lubridate}-function use by packages
hist(
fn_distinct_count$n,
breaks = 30,
main = "Distinct {lubridate} functions used by\npackages importing {lubridate}",
xlab = "Function count"
)
```