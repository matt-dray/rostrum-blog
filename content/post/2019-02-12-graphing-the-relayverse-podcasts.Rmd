---
title: Graphing the Relayverse podcasts
author: Matt Dray
date: '2019-02-12'
slug: relayverse
categories:
  - dataviz
  - pop culture
tags:
  - tidygraph
  - ggraph
  - networks
  - dplyr
  - purrr
  - visNetwork
draft: yes
---

# Relay FM

Podcasting is becoming big business. Music-streaming giant [Spotify](https://www.spotify.com/uk/) [acquired](https://investors.spotify.com/financials/press-release-details/2019/Spotify-Announces-Strategic-Acquisitions-to-Accelerate-Growth-in-Podcasting/default.aspx) the podcast network [Gimlet](https://www.gimletmedia.com/) last week for [a reported 200 million dollars](https://www.recode.net/2019/2/1/18207198/spotify-gimlet-podcast-acquisition).

Podcast networks act as centrally-managed collectives. This allows creators access to pooled expertise, management and resources while maximising ad revenue. Other examples of popular networks are [The Incomparable](https://www.theincomparable.com/), [5by5](http://5by5.tv/) and [Radiotopia](https://www.radiotopia.fm/).

[Relay FM](https://www.relay.fm) is a network that focuses largely on tech content. It was started by [Myke Hurley](https//www.relay.fm/people/mykehurley) and [Stephen Hackett](https//www.relay.fm/people/stephenhackett) in 2014.

Many of Relay FM's hosts have hosted more than one podcast on the network. This post is about exploring and visualising this 'Relayverse'.

# Packages

I'm using two suites of 'tidy' packages in this post: one set for data collection and manipulation, and one set for graph network building, analysis and visualisation.

```{r packages, warning=FALSE, message=FALSE}
# Data collection and manipulation
library(dplyr)  # data manipulation
library(rvest)  # for scraping webpages
library(stringr)  # string manipulation
library(tidyr)  # tidying dataframes
library(purrr)  # applying functions over data

# Graph networks
library(tidygraph)  # set up graph network
library(ggraph)  # visualise static graphs
library(visNetwork)  # javascript interactive network
```

# Harvest data

We can use the `rvest` package to scrape podcast details from [the Wikipedia page for Relay FM](https://en.wikipedia.org/wiki/Relay_FM). `read_html()` gets the HTML for the selected page; `html_node()` identifies which element needs to be scraped; and `html_table()` interprets the HTML information as a dataframe.

```{r scrape}
# Get the HTML for the selected page
relay_wiki <- read_html("https://en.wikipedia.org/wiki/Relay_FM")

# Get the table with current shows
current <- relay_wiki %>%
  html_node(xpath = '//*[@id="mw-content-text"]/div/table[2]') %>%
  html_table() %>%
  filter(
    !Podcast %in% c("Members Only", 'Paid "Members Only" Shows', "B-Sides")
  ) %>%
  mutate(Status = "Current")  # label rows as current shows

# Get the table with retired shows
retired <- relay_wiki %>%
  html_node(xpath = '//*[@id="mw-content-text"]/div/table[3]') %>%
  html_table() %>%
  select(-`Number of episodes`) %>%
  mutate(Status = "Retired")  # label rows as retired shows

# Combine the tablesinto one dataframe
shows <- bind_rows(current, retired)
```

Host names are in the form 'First LastFirst Last'. We can split them apart where a lowercase letter is followed by an uppercase letter[^regex]. This leaves us with a list column that we can `unnest()` to get one row per podcast-host combination. Our datframe is now tidy and ready for Tidygraph.

```{r str-split}
shows_clean <- shows %>%
  mutate(
    Hosts = str_remove_all(Hosts, " \\(originally\\)"),
    Hosts = str_split(Hosts, "(?<=[a-z])(?=[A-Z])")
  ) %>% 
  unnest() %>% 
  select(Podcast, Hosts, Status)
```

# Tidygraph

Tidygraph was written by Tomas Lin Pedersen.

We need every host combination[^combo] for each podcast, which can be achieved with the `combn()` function. This gives us a pair of points ('nodes' in graph-speak) that can be connected by a line (an 'edge') to indicate their relationship.

```{r combos}
relay_combos <- shows_clean %>% 
  group_by(Podcast) %>%  # operate within each podcast
  filter(n() > 1) %>%  # where there's more than one
  split(.$Podcast) %>%  # split on podcast
  map(., 2) %>%
  map(~combn(.x, m = 2)) %>%   # all pair combiantions
  map(~t(.x)) %>%  # transpose the matrix
  map(as_tibble) %>%  # convert to a tibble dataframe
  bind_rows(.id = "Podcast") %>%  # list-element name to column
  select(V1, V2, Podcast)

print(relay_combos)
```

We can turn this dataframe of host-pair combinations into a tidygraph object with the `as_tbl_graph()` function. This class of object contains two dataframes (the nodes and the edges) and some metadata.

```{r as-tbl-graph}
relay_graph <- as_tbl_graph(relay_combos, directed = FALSE)

print(relay_graph)
```

# Visualisation

## Static with `ggraph`

Like `tidygraph`, `ggraph` was written by Tomas Lin Pedersen.

## Interactive with `visNetwork`

[The `visNetwork` package](https://datastorm-open.github.io/visNetwork/) wraps some JavaScript to make interactive network graphs. The `visNetwork()` function takes separate dataframes of edges and nodes, written in specific formats.

```{r visnetwork-prep}
# We need an ID value
#relay_combos_id <- mutate(relay_combos, id = as.character(row_number()))

# Dataframe of unique nodes with an ID value
nodes <- shows_clean %>%  # take our podcast-host dataset
  distinct(Hosts) %>%  # get column of unique hosts
  arrange(Hosts) %>% 
  mutate(id = as.character(row_number()), label = Hosts) %>% 
  select(-Hosts) #%>%  # provides pop up value on viz
  #mutate(title = label)  # provides pop-up value on viz

#
edges <- relay_combos %>% 
  left_join(nodes, by = c("V1" = "label")) %>% 
  left_join(nodes, by = c("V2" = "label")) %>%
  rename(from = id.x, to = id.y, title = Podcast)
```

Now we can just plug the data into the function.

```{r visnetwork}
visNetwork(nodes, edges, main = "The Relayverse") %>% 
  visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE) %>% 
  visInteraction(navigationButtons = TRUE)
```

[^regex]: The regex `(?<=[a-z])(?=[A-Z])` says split after but not including (`?<=`) a lowercase letter (`[a-z]`), and before but not including (`?=`) a capital letter (`[A-Z]`).
[^combo]: We don't need all the _permutations_. 'Federico Viticci to Stephen M. Hackett' is the same as 'Stephen M. Hackett to Federico Viticci' and we don't need both.