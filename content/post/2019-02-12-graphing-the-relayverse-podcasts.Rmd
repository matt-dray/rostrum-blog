---
title: Graphing the Relayverse podcasts
author: Matt Dray
date: '2019-02-12'
slug: relayverse
categories:
  - dataviz
  - pop culture
tags:
  - tidygraph
  - ggraph
  - networks
  - dplyr
  - purrr
  - visNetwork
draft: yes
---

# Relay FM

Podcasting has been growing for a number of years now and has become big business. The podcast network Gimlet was acquired by Spotify just last week.

What's a 'podcast network'? A few companies act as a 'stable' for multiple podcasts, which can help pool resources and serve content better.

[Relay FM](https://www.relay.fm) is a podcast network that focuses largely on tech content. It was started by [Myke Hurley](https//www.relay.fm/people/mykehurley) and [Stephen Hackett](https//www.relay.fm/people/stephenhackett) in 2014.

Many of Relay FM's hosts have hosted more than one podcast on the network. This post is about exploring and visualising this 'Relayverse'.

# Packages

I'm using two suites of 'tidy' packages in this post: one set for data collection and manipulation, and one set for graph network building, analysis and visualisation.

```{r packages, warning=FALSE, message=FALSE}
# Data collection and manipulation
library(dplyr)  # data manipulation
library(rvest)  # for scraping webpages
library(stringr)  # string manipulation
library(tidyr)  # tidying dataframes
library(purrr)  # applying functions over data

# Graph networks
library(tidygraph)  # set up graph network
library(ggraph)  # visualise static graphs
library(visNetwork)  # javascript interactive network
```

# Harvest data

We can use the `rvest` package to scrape podcast details from [the Wikipedia page for Relay FM](https://en.wikipedia.org/wiki/Relay_FM). `read_html()` gets the HTML for the selected page; `html_node()` identifies which element needs to be scraped; and `html_table()` interprets the HTML information as a dataframe.

```{r scrape}
# Get the HTML for the selected page
relay_wiki <- read_html("https://en.wikipedia.org/wiki/Relay_FM")

# Get the table with current shows
current <- relay_wiki %>%
  html_node(xpath = '//*[@id="mw-content-text"]/div/table[2]') %>%
  html_table() %>%
  filter(
    !Podcast %in% c("Members Only", 'Paid "Members Only" Shows', "B-Sides")
  ) %>%
  mutate(Status = "Current")  # label rows as current shows

# Get the table with retired shows
retired <- relay_wiki %>%
  html_node(xpath = '//*[@id="mw-content-text"]/div/table[3]') %>%
  html_table() %>%
  select(-`Number of episodes`) %>%
  mutate(Status = "Retired")  # label rows as retired shows

# Combine the tablesinto one dataframe
shows <- bind_rows(current, retired)
```

Host names are in the form 'First LastFirst Last'. We can split them apart where a lowercase letter is followed by an uppercase letter[^regex]. This leaves us with a list column that we can `unnest()` to get one row per podcast-host combination. Our datframe is now tidy and ready for Tidygraph.

```{r str-split}
shows_clean <- shows %>%
  mutate(
    Hosts = str_remove_all(Hosts, " \\(originally\\)"),
    Hosts = str_split(Hosts, "(?<=[a-z])(?=[A-Z])")
  ) %>% 
  unnest() %>% 
  select(Podcast, Hosts, Status)
```

# Tidygraph

Tidygraph was written by Tomas Lin Pedersen.

We need every host combination[^combo] for each podcast, which can be achieved with the `combn()` function. This gives us a pair of points ('nodes' in graph-speak) that can be connected by a line (an 'edge') to indicate their relationship.

```{r combos}
relay_combos <- shows_clean %>% 
  group_by(Podcast) %>%  # operate within each podcast
  filter(n() > 1) %>%  # where there's more than one
  split(.$Podcast) %>%  # split on podcast
  map(., 2) %>%
  map(~combn(.x, m = 2)) %>%   # all pair combiantions
  map(~t(.x)) %>%  # transpose the matrix
  map(as_tibble) %>%  # convert to a tibble dataframe
  bind_rows(.id = "Podcast") %>%  # list-element name to column
  select(V1, V2, Podcast)

print(relay_combos)
```

We can turn this dataframe of host-pair combinations into a tidygraph object with the `as_tbl_graph()` function. This class of object contains two dataframes (the nodes and the edges) and some metadata.

```{r as-tbl-graph}
relay_graph <- as_tbl_graph(relay_combos, directed = FALSE)

print(relay_graph)
```

# Descriptive statistics

# Visualisation

## Static with `ggraph`

Like `tidygraph`, `ggraph` was written by Tomas Lin Pedersen.

## Interactive with `visNetwork`

I'm going to show how to use the `visNetwork` package, which wraps some JavaScript to allow for interactive networks. The `visNetwork()` takes separate dataframes of edges and nodes, written in specific formats.

```{r visnetwork-prep}
relay_combos_id <- mutate(relay_combos, id = row_number())

nodes <- shows_clean %>%
  distinct(Hosts) %>%
  mutate(id = as.character(row_number())) %>% 
  rename(label = Hosts) %>% 
  mutate(title = label)

edges <- left_join(relay_combos, nodes, by = c("V1" = "label")) %>% 
  left_join(nodes, by = c("V2" = "label")) %>% 
  mutate(title = Podcast) %>% 
  select(from = id.x, to = id.y, label = Podcast, title)
```

Now we can just plug the data into the function.

```{r visnetwork}
visNetwork(nodes, edges, main = "The Relayverse") %>% 
  visOptions(highlightNearest = TRUE, nodesIdSelection = TRUE)
```

[^regex]: The regex `(?<=[a-z])(?=[A-Z])` says split after but not including (`?<=`) a lowercase letter (`[a-z]`), and before but not including (`?=`) a capital letter (`[A-Z]`).
[^combo]: We don't need all the _permutations_. 'Federico Viticci to Stephen M. Hackett' is the same as 'Stephen M. Hackett to Federico Viticci' and we don't need both.