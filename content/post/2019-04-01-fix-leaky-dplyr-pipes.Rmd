---
title: Fix leaky pipes
author: Matt Dray
date: '2019-04-01'
slug: fix-leaky-pipes
categories:
  - R
tags:
  - dplyr
  - tidylog
  - pipecleaner
  - pipes
  - bizarro
  - magrittr
  - tidyverse
draft: yes
---

Matt Dray ([\@mattdray](https://www.twitter.com/mattdray))

## C'est un pipe

You know [the `%>%` (pipe) operator](https://magrittr.tidyverse.org/articles/magrittr.html) by now. It lets you chain function calls. It was created for [Stefan Milton Bache](http://stefanbache.dk/) and [Hadley Wickham](http://hadley.nz/)'s [{magrittr} package](https://CRAN.R-project.org/package=magrittr) and popularised by [the tidyverse](https://www.tidyverse.org/).

Voilà.

```{r pipeline-example}
# {dplyr} for data manipulation and to load pipe
suppressPackageStartupMessages(library(dplyr))

# Get mean sepal width for two iris species
iris_pipe <- iris %>%
  filter(Species %in% c("setosa", "versicolor")) %>% 
  group_by(Species) %>% 
  summarise(`Mean width` = mean(Sepal.Width)) %>% 
  mutate(`Mean width` = round(`Mean width`, 1))

# Print
iris_pipe
```

# Ce n'est pas debuggable?

[Some are critical of this approach](https://twitter.com/TedPetrou/status/1109519764613787648?ref_src=twsrc%5Etfw). Long pipes obscure what's happened to your data and make debugging hard. This post summarises some solutions.

This table summarises it even more.


| Package         | Description                                         | Message  | View     | Print    | Debug    |
| :---------------| :-------------------------------------------------- | :------: | :------: | :------: | :------: |
| {tidylog}       | Console-printed description of changes              | &#10004; | &#10008; | &#10008; | &#10008; |
| {ViewPipeSteps} | RStudio addin: see changes to dataset per step      | &#10008; | &#10004; | &#10004; | &#10008; |
| {tamper}        | Stack trace replacement for pipe debugging          | &#10004; | &#10008; | &#10008; | &#10004; |
| {pipecleaner}   | RStudio addin: 'burst' pipes and debug              | &#10008; | &#10008; | &#10008; | &#10004; |
| {magrittr}      | `debug_pipe()` function                             | &#10008; | &#10008; | &#10008; | &#10004; |
| {pipes}         | Special assignment operators                        | &#10008; | &#10004; | &#10004; | &#10004; |
| Bizarro pipe    | Replace `%>%` with `->.;` and observe `.Last.level` | &#10008; | &#10008; | &#10008; | &#10008; |

# Ce n'est pas une probleme?

I think most people create pipes interactively and check their outputs at each step.

You could also make sensibly-lengthed pipes that reflect a 'unit' of wrangling. Perhaps objects for the raw data as read-in, a reshaped version, one with cleaned columns, and another containing the model. You can then interrogate these easily.

Hadley Wickham discusses this in [the pipes chapter of the R for Data Science book](https://r4ds.had.co.nz/pipes.html). 

Nevertheless there are some options to help. I've split these into three categories (click to jump):

1. [Summary inspection](#summary-inspection)
    a. [{tidylog}](#tidylog)
    b. [{ViewPipeSteps}](#viewpipesteps)
1. [Debug mode](#debug-mode)
    a. [{tamper}](#tamper)
    b. [{pipecleaner}](#pipecleaner)
    c. [{magrittr}](#magrittr)
1. [Operator hacking](#operator-hacking)
    a. [{pipes}](#pipes)
    b. [Bizarro pipe](#bizarro-pipe)

# 1. Summary inspection {#summary-inspection}

These are packages for seeing what happened to your dataset at each step of your pipeline, rather than highlighting where the problem was.

## 1a. {tidylog} {#tidylog}

[The {tidylog} package](https://github.com/elbersb/tidylog) was written by [Benjamin Elbers](https://elbersb.de/public/). It prints to the console some summary sentences of the changes that have happened to your data after each {dplyr} step.

```{r tidylog-mask}
# install.packages("tidylog")  # available from CRAN
library(tidylog)  # must be loaded after dplyr
```

All the {dplyr} functions are masked by {tidylog}. This is so you caontinue use the same functions, but with the added side-effect of reporting the changes in the console. 

```{r tidylog-example}
iris_pipe <- iris %>%
  filter(Species %in% c("cycliophora", "onychophora")) %>% 
  group_by(Sepal.Width) %>% 
  summarise(`Mean width` = mean(Sepal.Width)) %>% 
  mutate(`Mean width` = round(`Mean width`, 1))
```

Did you spot the contrived error? I filtered for species[^species] that don't exist in the dataset, which was reported as `filter: removed all rows (100%)` in the first step.

This is a nice passive package that prints concisely to the console. You could argue that it doesn't do enough to grab your attention. You may still miss something if you have a pipeline that is too long (but you should split that up anyway).

I'll unload {tidylog} before continuing so it doesn't interfere with the other examples.

```{r tidylog-unload}
unloadNamespace("tidylog")
```

## 1b. {ViewPipeSteps} {#viewpipesteps}

[The {ViewPipeSteps} package](https://github.com/daranzolin/ViewPipeSteps) is an RStudio add-in created by [David Ranzolin](https://daranzolin.github.io/). Basically it runs `View()` or `print()` for each of the steps in your pipeline so you can see the the dataset.

```{r viewpipesteps, eval=FALSE}
remotes::install_github("daranzolin/ViewPipeSteps")  # not on CRAN
```

Then you can simply highlight your code and select 'View/Print Pipe Chain Steps' from the add-ins menu. Beware: this can be a lot to take in, especially if you have lots of steps in your pipeline.

# 2. Debug mode {#debug mode}

These are packages that help highlight where a problem occurred. A few of these take you to the [interactive debug menu](https://support.rstudio.com/hc/en-us/articles/205612627-Debugging-with-RStudio), which is worth reading up on if you haven't used it before.

## 2a. {tamper} {#tamper}

[Gábor Csárdi](http://gaborcsardi.org/)'s [{tamper} package](https://github.com/gaborcsardi/tamper) makes pipe debugging easier with a simple, informative interface. The package is currently available but is archived.

You set the error argument of the options to `tamper` once installed and loaded. From now on {tamper} will override the default stack trace report you get when an error is found.

Instead, {tamper} prints your pipeline in the console and highlights the problematic line with an arrow. Typing '0' will exit the {tamper} report; '1' switches you back to the stack trace; '2' will enter debug mode. 

This is friendly for beginners especially, since the {tamper} output is more readable.

```{r tamper, eval=FALSE}
# remotes::install_github("gaborcsardi/tamper")  # not on CRAN
library(tamper)

options(error = tamper::tamper)  # set error option to tamper

iris %>%
  filter(Species %in% c("setosa", "versicolor")) %>% 
  group_by(Species) %>% 
  summarise(`Mean width` = mean(Sepal.Girth)) %>%  # error here!
  mutate(`Mean width` = round(`Mean width`, 1))
```

```{r eval=FALSE}
# > iris_pipe <- iris %>%
# +   filter(Species %in% c("setosa", "versicolor")) %>% 
# +   group_by(Species) %>% 
# +   summarise(`Mean width` = mean(Sepal.Girth)) %>%
# +   mutate(`Mean width` = round(`Mean width`, 1))
# Error in mean(Sepal.Girth) : object 'Sepal.Girth' not found
# 
# Enter 0 to exit or choose: 
# 
# 1:    Switch mode
# 2:    Take me to the error
# 
# 3:    iris %>%
# 4: ->   filter(., Species %in% c("setosa", "versicolor")) %>%
# 5:      group_by(., Species) %>%
# 6:      summarise(., `Mean width` = mean(Sepal.Girth)) %>%
# 7:      mutate(., `Mean width` = round(`Mean width`, 1)) 
# 
# Selection: 
```

## 2b. {pipecleaner} {#pipecleaner}

[The {pipecleaner} package](https://alistaire47.github.io/pipecleaner/index.html) is an RStudio addin by [Edward Visel]. It has the best name.

You highlight your code and select 'Debug pipeline' from the Addins menu. The function does two things: first it 'bursts' your pipes (nice analogy) by breaking the pipeline into intermediate objects, one for each function that's contained within it. The interactive debug menu is then opened so you can execute your code step-by-step, see the results and perform other debug operations.

```{r burst-pipe, eval=FALSE}
# remotes::install_github("alistaire47/pipecleaner")  # not on CRAN
library(pipecleaner)

# Intact, original pipeline
iris_pipe <- iris %>%
  filter(Species %in% c("nope", "uh-uh")) %>% 
  group_by(Sepal.Width) %>% 
  summarise(`Mean width` = mean(Sepal.Width)) %>% 
  mutate(`Mean width` = round(`Mean width`, 1))

# After 'bursting' with the addin
dot1 <- filter(iris, Species %in% c("setosa", "versicolor"))
dot2 <- group_by(dot1, Species)
dot3 <- summarise(dot2, `Mean width` = mean(Sepal.Width))
iris_pipe <- mutate(dot3, `Mean width` = round(`Mean width`,1))
```

You can also choose 'Burst pipes' from the Addins menu without entering debug mode. 

## 2c. {magrittr} {#magrittr}

Surprise: [the {magrittr} package](https://magrittr.tidyverse.org/reference/debug_pipe.html) itself has the function `debug_pipe()` to take you directly to the debug menu from a pipeline.

```{r magrittr-example, eval=FALSE}
library(magrittr)

test <- iris %>%
  filter(Species %in% c("setosa", "versicolor")) %>%
  group_by(Species) %>% 
  summarise(`Mean width` = mean(Sepal.Width)) %>% 
  mutate(`Mean width` = round(`Mean width`, 1)) %>% debug_pipe()
```

# 3. Operator hacking

It's possible to make variant pipe operators. But do we even need `%>%`?

## 3a. {pipes} {#pipes}

[Antoine Fabri](https://github.com/moodymudskipper) forked the {magrittr} GitHub repo to add a bunch of `%>%` variants that have side properties. These are available from his [{pipes} package](https://github.com/moodymudskipper/pipes).

A few of direct relevance to this discussion:

* `%P>%` to `print()` the datset to the console
* `%V>%` will `View()` the full dataset
* `%D>%` open with debug menu

Others apply different functions during the piping step. There's some nice ones for summaries, like `%glimpse>%` and `%skim>%`.

Here's an example of `%P>%` that pipes forward into the next function and prints it to console. The final outut isn't printed because I've assigned it to `iris_pipes()`.

```{r pipes-example}
# remotes::install_github("moodymudskipper/pipes")  # not on CRAN
library(pipes)

iris_pipes <- iris %>%
  filter(Species %in% c("setosa", "versicolor")) %>% 
  group_by(Species) %P>% 
  summarise(`Mean width` = mean(Sepal.Width)) %>%
  mutate(`Mean width` = round(`Mean width`, 1))
```

## 3b. Bizarro pipe {#bizarro-pipe}

We can create an operator that acts like a pipe and can be run so that we can check what's happening at each step.

[John Mount](http://www.win-vector.com/site/staff/john-mount/)'s solution is [the 'Bizarro pipe'](http://www.win-vector.com/blog/2017/01/using-the-bizarro-pipe-to-debug-magrittr-pipelines-in-r/): `->.;`. This means 'right-assign to a period and then perform the next operation'.

Things you might be wondering:

* yes, you can use a `->` for assignment to the right
* yes, you can assign to a `.`, but you'll need to explicitly supply it as the data argumnt to the next function call in your Bizarro pipeline
* yes, you can use semi-colons in R for run-on code execution (try `head(iris); tail(iris)`)

So what? Well, you can exeute each line in turn and check the output. But wait: an object called `.` is not presented in the global environment. Not unless you check 'Show .Last.value in environment listing' in RStudio's settings. Now when you run the line you'll see the '.Last.value' that's been output.

```{r bizarro-example}
iris_bizarre <- iris ->.;
  filter(., Species %in% c("setosa", "versicolor")) ->.;
  group_by(., Species) ->.;
  summarise(., `Mean width` = mean(Sepal.Width)) ->.;
  mutate(., `Mean width` = round(`Mean width`, 1))
```

So slightly convoluted, but no dependencies needed.

[^species]: Welcome to Biology Geek Corner. Cycliophora is a phylum of animals containing just one species that lives exclusively on lobster lips. Onychophora is the velvet worm phylum that contains wee beasties that spray slime, have little adorable claws and are, surprise, velvety (one species is named 'totoro' becuase of its similarity to My Neighbout Totoro's Catbus).