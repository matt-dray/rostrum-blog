---
title: 'Can {drake} RAP?'
author: Matt Dray
date: '2019-06-10'
slug: drake-lays-an-egg
categories:
  - R
tags:
  - reproducibility
  - drake
  - eggs
  - rap
  - reproducible analytical pipelines
  - make
  - make file
draft: yes
---



<div id="tldr" class="section level1">
<h1>tl;dr</h1>
</div>
<div id="rap" class="section level1">
<h1>RAP</h1>
<p><a href="https://ukgovdatascience.github.io/rap-website/">Reproducible Analytical Pipelines</a> (RAP) is an approach to generating <a href="https://www.gov.uk/search/research-and-statistics">UK government’s statistical reports</a> that improves reproducibility, minimises errors and speeds up production.</p>
<p>RAP does away with the tangled webs of spreadsheets, copy-pasting errors and infernal <code>publication_FINAL-v2_md-comments_FINAL.docx</code> file naming. Instead, RAP encourages a script-based workflow that’s beefed up with stuff like version control, dependency management and automated testing.</p>
</div>
<div id="make" class="section level1">
<h1>Make</h1>
<p>Projects can become complicated as multiple inputs, script files and outputs build up.</p>
<p>You need to re-run code if any changes are made. Can you remember exactly which bits of code need to be re-run? Or will you have to re-run everything from scratch? The latter is especially tedious in a large project.</p>
<p>A <a href="https://en.wikipedia.org/wiki/Makefile">‘makefile’</a> can help you. In short, it’s a text file in which you write each step of your analysis in a recipe-like format. Dependencies between data, code and outputs are recorded.</p>
<p>Now when something changes, only the impacted steps will be re-executed. This saves compute time and means you don’t have to remember any dependencies yourself.</p>
</div>
<div id="drake-it-to-make-it" class="section level1">
<h1>{drake} it to make it</h1>
<p><a href="https://github.com/ropensci/drake">{drake}</a> is a package by <a href="https://wlandau.github.io/">Will Landau</a> that lets you have all the benefits of makefiles with R syntax.</p>
<p>With {drake} you prepare a ‘plan’ script written in R that records all the functions to be executed. You then ‘make’ the plan to run all the steps of the analysis.</p>
<p>There’s some helpful material out there for learning more about {drake}:</p>
<ul>
<li><a href="https://ropenscilabs.github.io/drake-manual/">user manual</a></li>
<li><a href="https://ropensci.github.io/drake/">documentation</a></li>
<li><a href="https://github.com/krlmlr/drake-sib-zurich/blob/master/cheat-sheet.pdf">cheat sheet</a> by Kirill Müller</li>
<li><a href="https://aedobbyn.github.io/nyc-fires/index.html#1">‘drake for workflow happiness’</a> slides by <a href="https://dobb.ae/">Amanda Dobbyn</a></li>
</ul>
</div>
<div id="eggsample" class="section level1">
<h1>Eggsample</h1>
<p>I’ve made a very simple {drake} demo for an imaginary RAP project, which recreates a small part of a <a href="https://www.gov.uk/government/statistics/egg-statistics">statistical publication that tracks UK egg production</a><a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a>.</p>
<p>The code is on <a href="https://github.com/matt-dray/drake-egg-rap">GitHub</a>, along with an <a href="https://matt-dray.github.io/drake-egg-rap/egg-report.html">HTML version of the demo report</a>.</p>
<div id="a-cunning-plan" class="section level2">
<h2>A cunning plan</h2>
<p>The repo contains <a href="https://github.com/matt-dray/drake-egg-rap/tree/master/R">a folder</a> with three simple but important scripts<a href="#fn2" class="footnote-ref" id="fnref2"><sup>2</sup></a>:</p>
<ol style="list-style-type: decimal">
<li><a href="https://github.com/matt-dray/drake-egg-rap/blob/master/R/packages.R"><code>packages.R</code></a> loads the packages we need for analysis using calls to <code>library()</code></li>
<li><a href="https://github.com/matt-dray/drake-egg-rap/blob/master/R/functions.R"><code>functions.R</code></a> contains bespoke functions</li>
<li><a href="https://github.com/matt-dray/drake-egg-rap/blob/master/R/plan.R"><code>plan.R</code></a> is the recipe document that brings everything together</li>
</ol>
<p>The first two don’t need much more explaining. The <code>plan.R</code> file is a little different but is straightforward. It contains a call to <code>drake::drake_plan()</code>, to which you pass the functions that make up your analysis:</p>
<pre class="r"><code>plan &lt;- drake_plan(
  
  raw_data = read_ods(
    path = &quot;data/eggs-packers-02may19a.ods&quot;,
    sheet = &quot;Packers_Annual&quot;,
    skip = 8
  ),
  
  data = clean_data(raw_data),
  
  plot = create_plot(data),
  
  report = rmarkdown::render(
    knitr_in(&quot;egg-report.Rmd&quot;),
    output_file = file_out(&quot;docs/egg-report.html&quot;),
    quiet = TRUE
  )

)</code></pre>
</div>
<div id="straight-from-the-source" class="section level2">
<h2>Straight from the source</h2>
<p>There is <a href="https://github.com/matt-dray/drake-egg-rap/blob/master/make.R">a simple file called <code>make.R</code> in the root</a> that reads each of the .R script files using the <code>source()</code> function. The first two scripts simply load the packages and functions we need, while <code>source(plan.R)</code> generates a data frame<a href="#fn3" class="footnote-ref" id="fnref3"><sup>3</sup></a> called ‘plan’.</p>
<p>The plan data frame has ‘target’ and ‘command’ columns and multiple rows. It acts like instruction booklet that can be read ‘for each function we specified in the <code>plan.R</code> file, apply the named command to the named target’.</p>
<p>So <a href="https://github.com/matt-dray/drake-egg-rap/blob/master/R/plan.R">in my simple example plan</a> there are four instructions:</p>
<ol style="list-style-type: decimal">
<li>Read the raw data (target) with <code>readODS::read_ods()</code> (command)</li>
<li>Clean the data (target) with our <code>clean_data()</code> function (command)</li>
<li>Plot the data (target) with our <code>plot_data()</code> function (command)</li>
<li>Create an R Markdown report (target) with <code>rmarkdown::render()</code> (command)</li>
</ol>
<p>The plan is executed with <code>make(plan)</code>. This runs all the instructions and outputs an HTML report, since the last step of the plan was to render an R Markdown file.</p>
<p>Great, our {drake} pipeline is successful.</p>
</div>
<div id="visualise" class="section level2">
<h2>Visualise</h2>
<p>{drake} provides some visual methods for inspecting the dependencies between targets. For example, it uses {visNetwork} to create an interactive graph.</p>
<p>{drake} provides some possibilities for visualising the dependencies between targets and highlights which are up to date.</p>
<p>First you generate ‘config’ file: a list object that contains lots of configuration information for your plan. One element is an igraph object that helps construct graphs from your workflow.</p>
<pre class="r"><code>egg_config &lt;- drake_config(plan)</code></pre>
<p>A number of {drake} functions can take the config object and do something with the information inside it. In our case, we’re going to pass the config to <code>vis_drake_graph()</code>, which builds an interactive dependency graph based on {visNetwork}.</p>
<pre class="r"><code>vis_drake_graph(egg_config)</code></pre>
<p><a href="https://matt-dray.github.io/drake-egg-rap/dependency-graph.html">The interactive output</a> is handy for seeing dependencies at a glance. It’s shape-coded to show the target type (object, function, file) and colour-coded to show whether everything is up-to-date.</p>
</div>
<div id="making-a-change" class="section level2">
<h2>Making a change</h2>
<p>Of course, re-running the plan again does… nothing. No code needs to be re-executed if nothing’s changed! Remember that {drake} will identify changes for you and re-execute only the dependent parts.</p>
<p>However, if a single data point or line of code changes, then the the downstream targets – the plot and the report – will be out of sync. You can check this with <code>outdated(egg_config)</code>.</p>
<p>If we <a href="https://matt-dray.github.io/drake-egg-rap/dependency-graph-outdated.html">take another look at the visualisation now</a>, we can see that certain targets have been recoloured to show that they’re out of date.</p>
<p>Re-running the plan will cause these targets to be regenerated. Targets that aren’t impacted by the change won’t be re-run.</p>
<p>Where are the targets stored that didn’t need to be recreated? Turns out that {drake} creates a <code>.drake/</code> folder to caches these objects and grabs then when needed.</p>
<p>Items can be pulled from this cache by the user with the the <code>loadd()</code> and <code>readd()</code> functions. For example, the R Markdown report in my example simply calls the rendered plot object from the cache using <code>readd()</code>. This can help keep the R Markdown file less cluttered and more readable.</p>
</div>
</div>
<div id="going-further" class="section level1">
<h1>Going further</h1>
<ul>
<li>complicated projects</li>
<li>high performance computing</li>
</ul>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>This publication could be a good candidate for RAP: content remains fairly similar between quarterly releases and it’s required to meet high standards of quality because it’s badged as <a href="https://www.statisticsauthority.gov.uk/osr/list-of-national-statistics/">National Statistics</a>.<a href="#fnref1" class="footnote-back">↩</a></p></li>
<li id="fn2"><p>You don’t have to restrict yourself to this configuration of scripts, but it can make it easier to handle your project.<a href="#fnref2" class="footnote-back">↩</a></p></li>
<li id="fn3"><p>It actually has multiple classes: <code>drake_plan</code>, <code>tbl_df</code>, <code>tbl</code> and <code>data.frame</code>.<a href="#fnref3" class="footnote-back">↩</a></p></li>
</ol>
</div>
