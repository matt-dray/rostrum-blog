---
title: 'Make the simplest R package with {pico}'
author: Matt Dray
date: '2021-04-18'
slug: pico-pkg
categories:
  - code
  - package
tags:
  - pico
  - r
  - usethis
draft: no
---

```{r setup, include=FALSE}
if (any(as.data.frame(installed.packages())$Package == "mypkg")) {
 remove.packages("mypkg")
}
```

<div class="figure">
<img src="https://raw.githubusercontent.com/matt-dray/stickers/master/output/pico_hex.png" alt="Hexagonal logo for the pico package with the package name in very small font in light brown on a darker brown background." width=200/>

# tl;dr

I made [{pico}](https://github.com/matt-dray/pico), an R package for creating R packages with the absolute minimum structure and content. You probably shouldn't use it.

# Function in a haystack

I saw [a \@WeAreRLadies tweet](https://twitter.com/WeAreRLadies/status/1383135972926296064) from last week's curator, [\@ShreyaLouis](https://twitter.com/ShreyaLouis). The gist was 'how can you be more organised when recalling and reusing your own R code?'

See [the thread](https://twitter.com/WeAreRLadies/status/1383135972926296064) for ideas, but I had [the same thought as Fabio](https://twitter.com/favstats/status/1383138145491943425?s=20): create a personal package of your frequently-used functions so you can invoke them whenever you want.[^onetweet]

# What's the problem?

[Packages are daunting](https://twitter.com/WeAreRLadies/status/1383142336050384896?s=20), particularly if you haven't made one before. I'm written a number of packages for fun and I still have no idea of the full ins and outs.

The esoteric structure and content of R packages are a barrier to beginners. Like, what is the `man/` folder and what's an `.Rd` file? It's easy to look at a chonky package repo on GitHub, like the popular [{dplyr}](https://github.com/tidyverse/dplyr/), and despair.

Yes, you could RTFM ('Read the Hecking Manual'), but have you [looked at it](http://www.hep.by/gnu/r-patched/r-exts/R-exts.html#SEC_Top) before? And it's not even necessary if you don't have dreams of submitting to CRAN.

What if---for teaching purposes---we strip back to the absolute barest of package requirements with the goal of demystification and to make it easier to get started? 

# Minimalism

So what's the least we need for a functioning package? Well, following [Karl Broman](http://kbroman.org/pkg_primer/pages/minimal.html), all you need is two files and a subfolder.

Here's how it looks for an imaginary package called {mypkg}:

```
mypkg/
├── R/
│   └── functions.R
└── DESCRIPTION
```

The `mypkg/R/functions.R` file is a normal R script where you put your function definitions, like:

```{r eval=FALSE}
say_hi <- function(name = "buddy") {
  paste0("Ahoy-hoy ", name, "!")
}
```

The `DESCRIPTION` file might not be as familiar, but it's basically a text file with two lines: the package name and a version number. You don't need to worry too much about the version number for now; a suffix of `9000` indicates a package in development.

```
Package: mypkg
Version: 0.0.0.9000
```

...and that's all that's required.

# Introducing {pico}

So, you could point-and-click to create a folder with the structure and content outlined above, but I've also created [the {pico} package](https://github.com/matt-dray/pico) to do it for you. The basic process is:

1. Install {pico} with `remotes::install_github("matt-dray/pico")`
1. Create your package with e.g. `pico::create("mypkg", "~/Documents/")`
1. Add new function definitions to `mypkg/R/functions.R`
1. Install your package with `remotes::install_local("~/Documents/mypkg")` and attach like usual with `library(mypkg)`

Later you can add more functions to `R/functions.R` and can reinstall the package with `install_local()`, using the `force = TRUE` argument to overwrite the old version.

Let's take a look at those steps in a bit more depth.

## Install {pico}

First, you can install {pico} [from GitHub](https://github.com/matt-dray/pico) with help from the {remotes} package.

```{r eval=FALSE}
install.packages("remotes")
remotes::install_github("matt-dray/pico")
```

You can look up the help files with `?pico::create()` at any time.

It's a really small package, but let me know if you [find any bugs](https://github.com/matt-dray/pico/issues) or you want to contribute.

## Create

There's only one function in {pico}: `create()`. It generates a 'pico package' with the minimum required content. You supply a package `name` and a `dir`ectory where you want your package folder to be generated.

As a demonstration, here’s how to create a pico package called {mypkg} in a temporary folder (put yours somewhere more permanent and convenient like `~/Documents` on macOS, for example):

```{r}
tmp <- tempdir()
pico::create(name = "mypkg", dir = tmp)
```

There's some output confirming your new package has been written to the location you specified (my example path here is nonstandard because it's a temporary location).

The name will be checked against R-package naming standards: it should contain alphanumeric characters or periods only, must have at least two characters, and can't start with a number nor end with a period. The provided directory also will be checked for existence and—--if it already contains a folder with the proposed name of your package—--you’ll be asked interactively if you want to overwrite it.

## Install your package

So, your package now exists on your computer. Now how do you use it?

Normally, you would use `install.packages()` to fetch a package from CRAN and install it to your computer's R package library. We can do something similar, but instead of fetching from CRAN, we can fetch the package 'locally', i.e. from your computer.

To do this, we can use the {remotes} package, which we installed earlier. It contains an `install_local()` function to which you pass the package’s filepath on your computer:

```{r echo=TRUE, results='hide'}
remotes::install_local(path = file.path(tmp, "mypkg"))
```

```{r echo=FALSE}
cat(
  "✓  checking for file ", paste0("‘private", tmp, "/mypkg"), "’ ...\n",
  "─  preparing ‘mypkg’:\n",
  "✓  checking DESCRIPTION meta-information\n",
  "─  checking for LF line-endings in source and make files and shell scripts\n",
  "─  checking for empty or unneeded directories\n",
  "─  creating default NAMESPACE file\n",
  "─  building ‘mypkg_0.0.9000.tar.gz’\n",
  "\n",
  "* installing *source* package ‘mypkg’ ...\n",
  "** using staged installation\n",
  "** R\n",
  "** byte-compile and prepare package for lazy loading\n",
  "** help\n",
  "No man pages found in package  ‘mypkg’ \n",
  "*** installing help indices\n",
  "** building package indices\n",
  "** testing if installed package can be loaded from temporary location\n",
  "** testing if installed package can be loaded from final location\n",
  "** testing if installed package keeps a record of temporary installation path\n",
  "* DONE (mypkg)\n"
)
```

You'll see some output that describes the installation process, ending with `DONE`.

The package is now installed into your R package library and can be attached like any other package.

```{r}
library(mypkg)
```

Now the functions from the package are available for use. By default, `create()` adds a dummy function called `say_hi()` to `R/functions.R`, so we can use it now:

```{r}
say_hi("chums")
```

This means that all those functions you wanted to reuse---that you forget or are stored across multiple locations---are available from within this one package with very simple structure. And all it required was `install_github()`, `create()` and `install_local()`.

# Add new functions

Of course, you can add your own functions to your pico package. The basic steps are:

1. Open the `mypkg/R/functions.R` script
1. Paste in your function definitions and save the file
1. Rerun `remotes::install_local()` with the argument `force = TRUE`, then restart R

Here's what this might look like for our example package. First, you might add the function `say_bye()` by adding these lines to the `functions.R` file:

```{r}
say_bye <- function(name = "folks") {
  paste0("Cheerio ", name, "!")
}
```

After you saved the updated file, you can re-run `install_local()` with the file path and `force = TRUE`, which will overwrite the old version in the package library.

```{r eval=FALSE}
# Not run
remotes::install_local(
 path = file.path(tmp, "mypkg"),
 force = TRUE
)
```

You must restart R after you've done this.

Your new functions will then be available from your package, much like the dummy `say_hi()` function was. Here's `say_bye()`:

```{r}
library(mypkg)
say_bye("friends")
```

# Huge limitations

So, I think {pico} is a quick way to get you from 'no-package' to 'package' quickly, but more importantly it has none of the esoteric, daunting structure and content of a 'normal' package.

However.

A pico package doesn't encourage best practice, nor is it very useful for sharing. That's why I think the only practical applications are for learning the basics of package structure, or for building a small package of functions that you might personally want to use again in future.

I would absolutely advocate for learning how to make a 'real' package, because that additional structure and content is really powerful and exists for a reason. For example, we haven't documented any of our functions. What if you add a function to your package but you can't remember how to use it? We also haven't tested anything. What if something breaks? 

I've [written before about the wonders of {usethis}](https://www.rostrum.blog/2019/11/01/usethis/), a package made specifically to help develop your own R packages without thinking too hard. I believe it provides the perfect starting point for developing your own package without worrying about exactly what files are needed and where.

There's a vast array of free web-based resources out there for package building. For example, some that I've found useful are:

* [Hilary Parker’s _Writing an R Package from Scratch_ post](https://hilaryparker.com/2014/04/29/writing-an-r-package-from-scratch/)
* [Tom Westlake’s update to Hilary’s post](https://r-mageddon.netlify.com/post/writing-an-r-package-from-scratch/)
* [Emil Hvitfeldt’s {usethis} workflow](https://www.hvitfeldt.me/blog/usethis-workflow-for-package-development/)
* [Karl Broman’s _R Package Primer_ site](https://kbroman.org/pkg_primer/), a primer for package development
* [Hadley Wickham’s _R Packages_ book](http://r-pkgs.had.co.nz/)

You should make use of those resources, for sure. Do not use {pico} for any serious work. {pico}'s purpose here is to think about how we might demystify package development. At worst I think it's an interesting curiosity. 

---
<details><summary>Session info</summary>
```{r sessioninfo, echo=FALSE}
sessioninfo::session_info()
```
</details>

```{r include=FALSE}
# Tidy up
unlink(file.path(tmp, "mypkg"), recursive = TRUE)
if (any(as.data.frame(installed.packages())$Package == "mypkg")) {
 remove.packages("mypkg")
}
```

[^onetweet]: My initial thought was to try and respond---in a single tweet---with the code required to build a package. That might help show how little code is required, especially with shortcuts like `usethis::create_package()` and `usethis::use_r()`. But I think there's a little too much extra explanation required for this to be a viable, helpful response.