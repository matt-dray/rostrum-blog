---
draft:yes
title: Art of the Possible
author: Matt Dray
date: '2018-11-01'
slug: art-of-the-possible
---



<p>Matt Dray</p>
<div id="colour-search" class="section level1">
<h1>Colour search</h1>
<p>Searching images by colour is all the rage:</p>
<ul>
<li><a href="https://artsexperiments.withgoogle.com/artpalette/colors/a46053-433932-c2ad8f-b5996a-746251">Google Arts &amp; Culture</a></li>
<li><a href="https://www.designspiration.net/search/saves/?q=%2389ebd7%20%23afff11%20%23e5ff91%20%23ff9775%20%23f38d00">Designspiration</a></li>
<li><a href="https://labs.tineye.com/multicolr/">TinEye Multicolr</a></li>
<li><a href="https://www.google.co.uk/advanced_image_search">Google Advanced Image Search</a></li>
<li><a href="https://www.dulux.co.uk/en/articles/dulux-visualizer-app">Dulux colour match</a></li>
</ul>
<p>To do this you need to know how much of each colour is in the image.</p>
<p>So let’s look at a kind-of-crappy half-baked method in R for achieving this.</p>
</div>
<div id="a-very-simple-implementation" class="section level1">
<h1>A very simple implementation</h1>
<p>The steps go like this:</p>
<ol style="list-style-type: decimal">
<li>Read in an image</li>
<li>Convert RGB (Red-Green-Blue) values to simple-named colours</li>
<li>Get percentage of image filled by each colour</li>
<li>???</li>
<li>Profit</li>
</ol>
</div>
<div id="read-image" class="section level1">
<h1>Read image</h1>
<p>There’s a number of ways to read images into R. We’ll use the <code>readImage()</code> function from the <code>OpenImageR</code> package.</p>
<p>Remember to use <code>install.packages()</code> if you haven’t installed any of the packages in this post. I’m also assuming that you have a test image, named <code>test_image.jpg</code>, in a folder called <code>img</code> in your working directory.</p>
<p>We’re using <a href="https://commons.wikimedia.org/wiki/Flowers#/media/File:L%C3%B6wenzahn-JJ5.jpg">an image of a dandelion from Wikimedia Commons</a>.</p>
<pre class="r"><code>library(OpenImageR)  # load package
image_in &lt;- readImage(&quot;img/test_image.png&quot;)  # read image
imageShow(image_in)  # print image to viewer</code></pre>
<p><img src="/post/2018-11-01-art-of-the-possible_files/figure-html/unnamed-chunk-2-1.png" width="672" /></p>
<p>The image has been read into R as an <em>array</em>, an object type that can hold data in multiple dimensions.</p>
<p>Our image has three dimensions: a two-dimensional matrix representing the ‘pixels’ of the image plus <a href="https://en.wikipedia.org/wiki/Channel_(digital_image)">a third dimension for each ‘colour channel’ of red, green and blue (RGB)</a>.</p>
<p>You can see this when you check the <code>str</code>ucture of the image:</p>
<pre class="r"><code>str(image_in)  # check structure</code></pre>
<pre><code>##  num [1:800, 1:600, 1:3] 0.255 0.255 0.259 0.263 0.263 ...</code></pre>
<p>So it’s indexed as <code>[matrix rows, matrix columns, colour channels]</code>. There’ll be three colour channels, of course: RGB. The number of rows and columns will depend on how big the image is.</p>
<p>So we could get the values of each colour channel for the top-left nine pixels of the image (a three-by-thre matrix).</p>
<pre class="r"><code># first three elements of first two dimensions
# and all the elements of the third dimension
image_in[1:3, 1:3, ]</code></pre>
<pre><code>## , , 1
## 
##           [,1]      [,2]      [,3]
## [1,] 0.2549020 0.2549020 0.2549020
## [2,] 0.2549020 0.2549020 0.2549020
## [3,] 0.2588235 0.2588235 0.2588235
## 
## , , 2
## 
##           [,1]      [,2]      [,3]
## [1,] 0.4039216 0.4039216 0.4039216
## [2,] 0.4039216 0.4039216 0.4039216
## [3,] 0.4078431 0.4078431 0.4078431
## 
## , , 3
## 
##           [,1]      [,2]      [,3]
## [1,] 0.6901961 0.6901961 0.6901961
## [2,] 0.6901961 0.6901961 0.6901961
## [3,] 0.6941176 0.6941176 0.6941176</code></pre>
<p>For example, a point will be yellow if it has maximum values for red and blue channels and the minimum value in the green channel. <a href="http://web.stanford.edu/class/cs101/image-rgb-explorer.html">There are online tools for exploring RGB permutations</a>.</p>
</div>
<div id="tidy-the-data" class="section level1">
<h1>Tidy the data</h1>
<p>We begin by reorganising the array into a dataframe using <code>melt()</code> from the <code>reshape2</code> package.<a href="#fn1" class="footnote-ref" id="fnref1"><sup>1</sup></a> This gives us four columns: one for each pixel’s x and y value, one for the RGB channel (1 = red, 2 = green, 3 = blue) and one that gives the actual colour value for that channel.</p>
<pre class="r"><code>library(dplyr)  # for data manipulation
library(reshape2)  # reformat wide to long

image_melt &lt;- image_in %&gt;%
  melt() %&gt;% # long format
  rename(  # change column names
    y_val = Var1,
    x_val = Var2,
    rgb_channel = Var3,
    rgb_value = value
  )

head(image_melt)  # show first few</code></pre>
<pre><code>##   y_val x_val rgb_channel rgb_value
## 1     1     1           1 0.2549020
## 2     2     1           1 0.2549020
## 3     3     1           1 0.2588235
## 4     4     1           1 0.2627451
## 5     5     1           1 0.2627451
## 6     6     1           1 0.2666667</code></pre>
<p>What we actually want is a dataframe with columns for each of the RGB channels. Since we’re working with a dataframe, we can use the <code>spread()</code> funciton in the <code>tidyr</code> package to set our ‘key’ as the RGB channel (i.e. the single column from which the levels will become new columns) and the ‘value’ as the RGB values. We multiply these values by 255 to get the classic 0 to 255 range.</p>
<pre class="r"><code>library(tidyr)  # to tidy dataframes
library(tibble)  # nice tables

image_spread &lt;- image_melt %&gt;% 
  spread(  # wide format
    key = rgb_channel,
    value = rgb_value
  ) %&gt;% 
  transmute(  # create and retain cols 
    red = round(`1` * 255),
    green = round(`2` * 255),
    blue = round(`3` * 255)
  ) %&gt;%
  rownames_to_column() %&gt;% # col to iterate over
  as_tibble()  # for nice printing

head(image_spread)  # first few rows</code></pre>
<pre><code>## # A tibble: 6 x 4
##   rowname   red green  blue
##   &lt;chr&gt;   &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 1          65   103   176
## 2 2          65   103   176
## 3 3          65   103   176
## 4 4          65   103   176
## 5 5          65   103   176
## 6 6          65   103   176</code></pre>
<p>So we have a four column dataframe: a column for each RGB channel and a column for arbitrary rownames. We don’t need to worry about the x and y values right now because we don’t want to rebuild the image, we just want to count the colours.</p>
</div>
<div id="assign-simple-colours" class="section level1">
<h1>Assign simple colours</h1>
<p>You could do k-means clustering to bucket the full colour set into <em>k</em> groups, each with a representative RGB value. This is a good approach for simplifying images; you could go from 256 colours to 8, for example. <a href="">You can find methods for this online</a>.</p>
<p>But actually we want to describe the image with <em>simple</em> colours, not the average of a cluster. So we could first convert the RGB values in our array to a set of basic colours with recognisable names like ‘yellow’ and ‘black’. Then we just tally them.</p>
<p>We can do this for each of our pixels by looking for the nearest-neighbour point in RGB space that describes a predefined ‘simple’ colour.</p>
<p>It’s kind of tricky to decide what these colours should be. One approach might be to use ‘extreme’ colours. For example, ‘blue’ could be categorised as lowest values for R and G, but highest value of B <code>[0, 0, 255]</code></p>
<pre class="r"><code>simple_colours &lt;- tibble::tribble(
  ~colour, ~red, ~green, ~blue,
  &quot;aqua&quot;,   0,   255, 255,
  &quot;black&quot;,   0,   0,   0,
  &quot;blue&quot;,    0,   0,   255,
  &quot;fuchsia&quot;, 255, 0,   255,
  &quot;gray&quot;,    128, 128, 128,
  &quot;green&quot;,   0,   128, 0,
  &quot;lime&quot;,    0,   255, 0,
  &quot;red&quot;,     128, 0,   0,
  &quot;navy&quot;,    0,   0,   128,
  &quot;olive&quot;,   128, 128, 0,
  &quot;purple&quot;,  128, 0,   128,
  &quot;red&quot;,     255, 0,   0,
  &quot;silver&quot;,  192, 192, 192,
  &quot;teal&quot;,    0,   128, 128,
  &quot;white&quot;,   255, 255, 255,
  &quot;yellow&quot;,  255, 255, 0
)</code></pre>
<p>We want to find the named point (e.g. yellow is at the point [255, 255, 0]) closest to each pixel and assign it that name.</p>
<p>We can do this by calculating the sum of the squared difference between the pixel value and named-point values for each colour channel. The pixel will be assigned where the calculated value is smallest.</p>
<pre class="r"><code>image_spread$colour_name &lt;- sapply(
  seq_along(image_spread$rowname),
  function(i) 
    simple_colours$colour[
      which.min(
        (simple_colours$red - image_spread$red[i])^2 +
          (simple_colours$green - image_spread$green[i])^2 +
          (simple_colours$blue - image_spread$blue[i])^2
      )
      ]
)</code></pre>
</div>
<div id="sum-the-colours" class="section level1">
<h1>Sum the colours</h1>
<p>And now we just work out the percentage of pixels belonging to each colour.</p>
<pre class="r"><code>library(janitor)  # misc tidy functions

image_colours &lt;- image_spread %&gt;% 
  tabyl(colour_name) %&gt;% 
  arrange(desc(percent))

print(image_colours)</code></pre>
<pre><code>##    colour_name      n      percent
## 1       silver 213583 4.449646e-01
## 2         gray 104131 2.169396e-01
## 3       yellow  44850 9.343750e-02
## 4        olive  43897 9.145208e-02
## 5        black  39994 8.332083e-02
## 6        white  29357 6.116042e-02
## 7        green   2607 5.431250e-03
## 8          red   1217 2.535417e-03
## 9         teal    242 5.041667e-04
## 10        navy    118 2.458333e-04
## 11      purple      4 8.333333e-06</code></pre>
</div>
<div id="session-info" class="section level1">
<h1>Session info</h1>
<pre class="r"><code>devtools::session_info()</code></pre>
<pre><code>## Session info -------------------------------------------------------------</code></pre>
<pre><code>##  setting  value                       
##  version  R version 3.5.1 (2018-07-02)
##  system   x86_64, darwin15.6.0        
##  ui       X11                         
##  language (EN)                        
##  collate  en_GB.UTF-8                 
##  tz       Europe/London               
##  date     2018-10-19</code></pre>
<pre><code>## Packages -----------------------------------------------------------------</code></pre>
<pre><code>##  package    * version date       source        
##  assertthat   0.2.0   2017-04-11 CRAN (R 3.5.0)
##  backports    1.1.2   2017-12-13 CRAN (R 3.5.0)
##  base       * 3.5.1   2018-07-05 local         
##  bindr        0.1.1   2018-03-13 CRAN (R 3.5.0)
##  bindrcpp   * 0.2.2   2018-03-29 CRAN (R 3.5.0)
##  blogdown     0.8     2018-07-15 CRAN (R 3.5.0)
##  bookdown     0.7     2018-02-18 CRAN (R 3.5.0)
##  cli          1.0.1   2018-09-25 CRAN (R 3.5.0)
##  compiler     3.5.1   2018-07-05 local         
##  crayon       1.3.4   2017-09-16 CRAN (R 3.5.0)
##  datasets   * 3.5.1   2018-07-05 local         
##  devtools     1.13.6  2018-06-27 CRAN (R 3.5.0)
##  digest       0.6.17  2018-09-12 CRAN (R 3.5.1)
##  dplyr      * 0.7.6   2018-06-29 CRAN (R 3.5.1)
##  evaluate     0.11    2018-07-17 CRAN (R 3.5.0)
##  fansi        0.3.0   2018-08-13 CRAN (R 3.5.0)
##  glue         1.3.0   2018-07-17 CRAN (R 3.5.0)
##  graphics   * 3.5.1   2018-07-05 local         
##  grDevices  * 3.5.1   2018-07-05 local         
##  grid         3.5.1   2018-07-05 local         
##  htmltools    0.3.6   2017-04-28 CRAN (R 3.5.0)
##  httpuv       1.4.5   2018-07-19 CRAN (R 3.5.0)
##  janitor    * 1.1.1   2018-07-31 CRAN (R 3.5.0)
##  jpeg         0.1-8   2014-01-23 CRAN (R 3.5.0)
##  knitr        1.20    2018-02-20 CRAN (R 3.5.0)
##  later        0.7.5   2018-09-18 CRAN (R 3.5.1)
##  magrittr     1.5     2014-11-22 CRAN (R 3.5.0)
##  memoise      1.1.0   2017-04-21 CRAN (R 3.5.0)
##  methods    * 3.5.1   2018-07-05 local         
##  mime         0.5     2016-07-07 CRAN (R 3.5.0)
##  OpenImageR * 1.1.1   2018-08-22 CRAN (R 3.5.0)
##  pillar       1.3.0   2018-07-14 CRAN (R 3.5.0)
##  pkgconfig    2.0.2   2018-08-16 CRAN (R 3.5.0)
##  plyr         1.8.4   2016-06-08 CRAN (R 3.5.0)
##  png          0.1-7   2013-12-03 CRAN (R 3.5.0)
##  promises     1.0.1   2018-04-13 CRAN (R 3.5.0)
##  purrr        0.2.5   2018-05-29 CRAN (R 3.5.0)
##  R6           2.2.2   2017-06-17 CRAN (R 3.5.0)
##  Rcpp         0.12.19 2018-10-01 CRAN (R 3.5.0)
##  reshape2   * 1.4.3   2017-12-11 CRAN (R 3.5.0)
##  rlang        0.2.2   2018-08-16 CRAN (R 3.5.0)
##  rmarkdown    1.10    2018-06-11 CRAN (R 3.5.0)
##  rprojroot    1.3-2   2018-01-03 CRAN (R 3.5.0)
##  shiny        1.1.0   2018-05-17 CRAN (R 3.5.0)
##  stats      * 3.5.1   2018-07-05 local         
##  stringi      1.2.4   2018-07-20 CRAN (R 3.5.0)
##  stringr      1.3.1   2018-05-10 CRAN (R 3.5.0)
##  tibble     * 1.4.2   2018-01-22 CRAN (R 3.5.0)
##  tidyr      * 0.8.1   2018-05-18 CRAN (R 3.5.0)
##  tidyselect   0.2.4   2018-02-26 CRAN (R 3.5.0)
##  tiff         0.1-5   2013-09-04 CRAN (R 3.5.0)
##  tools        3.5.1   2018-07-05 local         
##  utf8         1.1.4   2018-05-24 CRAN (R 3.5.0)
##  utils      * 3.5.1   2018-07-05 local         
##  withr        2.1.2   2018-03-15 CRAN (R 3.5.0)
##  xfun         0.3     2018-07-06 CRAN (R 3.5.0)
##  xtable       1.8-3   2018-08-29 CRAN (R 3.5.0)
##  yaml         2.2.0   2018-07-25 CRAN (R 3.5.0)</code></pre>
</div>
<div class="footnotes">
<hr />
<ol>
<li id="fn1"><p>Yeah, <code>reshape2</code> has been superseded by <code>tidyr</code>, but the latter was built to deal with dataframes specifically. We’re working with an <em>array</em> as input.<a href="#fnref1" class="footnote-back">↩</a></p></li>
</ol>
</div>
